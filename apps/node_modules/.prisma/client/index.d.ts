/**
 * Client
 **/

import * as runtime from '@prisma/client/runtime/index';

declare const prisma: unique symbol;
export type PrismaPromise<A> = Promise<A> & { [prisma]: true };
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P;
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}`
    ? Tuple[K] extends PrismaPromise<infer X>
      ? X
      : UnwrapPromise<Tuple[K]>
    : UnwrapPromise<Tuple[K]>;
};

/**
 * Model User
 *
 */
export type User = {
  userId: string;
  phoneNumber: string;
  isPhoneConfirmed: boolean;
  username: string;
  password: string;
  completeName: string | null;
  userRoleId: string;
  userAddressId: string | null;
  createdAt: Date | null;
  updatedAt: Date | null;
};

/**
 * Model Tokens
 *
 */
export type Tokens = {
  tokenId: string;
  token: string;
  userId: string;
  createdAt: Date | null;
  updatedAt: Date | null;
};

/**
 * Model Role
 *
 */
export type Role = {
  roleId: string;
  userRole: string;
  createdAt: Date | null;
  updatedAt: Date | null;
};

/**
 * Model Address
 *
 */
export type Address = {
  addressId: string;
  commune: string | null;
  address: string;
  longitude: string;
  latitude: string;
  restauId: string | null;
  userId: string | null;
  createdAt: Date | null;
  updatedAt: Date | null;
};

/**
 * Model Restaurant
 *
 */
export type Restaurant = {
  restauId: string;
  restauName: string;
  restauDescription: string;
  phoneNumber: string | null;
  email: string | null;
  restauAddressId: string | null;
  mainImageId: string | null;
  isActive: boolean;
  createdAt: Date | null;
  updatedAt: Date | null;
};

/**
 * Model RestauTokens
 *
 */
export type RestauTokens = {
  tokenId: string;
  token: string;
  restauUserId: string;
  createdAt: Date | null;
  updatedAt: Date | null;
};

/**
 * Model RestauUser
 *
 */
export type RestauUser = {
  restauUserId: string;
  restauId: string;
  userName: string;
  phoneNumber: string;
  completeName: string;
  userImage: string;
  password: string;
  role: RestauRole;
  createdAt: Date | null;
  updatedAt: Date | null;
};

/**
 * Model RestauImages
 *
 */
export type RestauImages = {
  imageId: string;
  address: string;
  publicUrl: string;
  imageUrl: string;
  restauId: string | null;
  createdAt: Date | null;
  updatedAt: Date | null;
};

/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const RestauRole: {
  ADMIN: 'ADMIN';
  AGENT: 'AGENT';
};

export type RestauRole = typeof RestauRole[keyof typeof RestauRole];

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T
    ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<T['log']>
      : never
    : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
> {
  /**
   * @private
   */
  private fetcher;
  /**
   * @private
   */
  private readonly dmmf;
  /**
   * @private
   */
  private connectionPromise?;
  /**
   * @private
   */
  private disconnectionPromise?;
  /**
   * @private
   */
  private readonly engineConfig;
  /**
   * @private
   */
  private readonly measurePerformance;

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U | 'beforeExit'>(
    eventType: V,
    callback: (
      event: V extends 'query'
        ? Prisma.QueryEvent
        : V extends 'beforeExit'
        ? () => Promise<void>
        : Prisma.LogEvent
    ) => void
  ): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void;

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(
    arg: [...P]
  ): Promise<UnwrapTuple<P>>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.tokens`: Exposes CRUD operations for the **Tokens** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Tokens
   * const tokens = await prisma.tokens.findMany()
   * ```
   */
  get tokens(): Prisma.TokensDelegate<GlobalReject>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Roles
   * const roles = await prisma.role.findMany()
   * ```
   */
  get role(): Prisma.RoleDelegate<GlobalReject>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Addresses
   * const addresses = await prisma.address.findMany()
   * ```
   */
  get address(): Prisma.AddressDelegate<GlobalReject>;

  /**
   * `prisma.restaurant`: Exposes CRUD operations for the **Restaurant** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Restaurants
   * const restaurants = await prisma.restaurant.findMany()
   * ```
   */
  get restaurant(): Prisma.RestaurantDelegate<GlobalReject>;

  /**
   * `prisma.restauTokens`: Exposes CRUD operations for the **RestauTokens** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more RestauTokens
   * const restauTokens = await prisma.restauTokens.findMany()
   * ```
   */
  get restauTokens(): Prisma.RestauTokensDelegate<GlobalReject>;

  /**
   * `prisma.restauUser`: Exposes CRUD operations for the **RestauUser** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more RestauUsers
   * const restauUsers = await prisma.restauUser.findMany()
   * ```
   */
  get restauUser(): Prisma.RestauUserDelegate<GlobalReject>;

  /**
   * `prisma.restauImages`: Exposes CRUD operations for the **RestauImages** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more RestauImages
   * const restauImages = await prisma.restauImages.findMany()
   * ```
   */
  get restauImages(): Prisma.RestauImagesDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;
  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;
  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;
  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  /**
   * Prisma Client JS version: 3.9.2
   * Query Engine version: bcc2ff906db47790ee902e7bbc76d7ffb1893009
   */
  export type PrismaVersion = {
    client: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from.
   */
  export type JsonObject = { [Key in string]?: JsonValue };

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue =
    | string
    | number
    | boolean
    | JsonObject
    | JsonArray
    | null;

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {
    readonly [Key in string]?: InputJsonValue | null;
  };

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray
    extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue =
    | string
    | number
    | boolean
    | InputJsonObject
    | InputJsonArray;

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull';

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull';

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull';

  type SelectAndInclude = {
    select: any;
    include: any;
  };
  type HasSelect = {
    select: any;
  };
  type HasInclude = {
    include: any;
  };
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S;

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<
    infer U
  >
    ? U
    : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> =
    PromiseType<ReturnType<T>>;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key;
  }[keyof T];

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T | U extends object
    ? (Without<T, U> & U) | (Without<U, T> & T)
    : T | U;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
    ? False
    : T extends Date
    ? False
    : T extends Buffer
    ? False
    : T extends BigInt
    ? False
    : T extends object
    ? True
    : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<
    __Either<O, K>
  >;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O
    ? O[K]
    : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown
    ? AtStrict<O, K>
    : never;
  export type At<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0;

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Exact<A, W = unknown> = W extends unknown
    ? A extends Narrowable
      ? Cast<A, W>
      : Cast<
          { [K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never },
          { [K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K] }
        >
    : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<
            UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never
          >
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<
    T,
    TupleToUnion<K>
  >;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}`
    ? never
    : T;

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(
      prisma: PrismaClient<any, any>,
      debug?: boolean,
      hooks?: Hooks | undefined
    );
    request<T>(
      document: any,
      dataPath?: string[],
      rootField?: string,
      typeName?: string,
      isList?: boolean,
      callsite?: string
    ): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(
      document: any,
      data: any,
      path: string[],
      rootField?: string,
      isList?: boolean
    ): any;
  }

  export const ModelName: {
    User: 'User';
    Tokens: 'Tokens';
    Role: 'Role';
    Address: 'Address';
    Restaurant: 'Restaurant';
    RestauTokens: 'RestauTokens';
    RestauUser: 'RestauUser';
    RestauImages: 'RestauImages';
  };

  export type ModelName = typeof ModelName[keyof typeof ModelName];

  export type Datasources = {
    db?: Datasource;
  };

  export type RejectOnNotFound = boolean | ((error: Error) => Error);
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound };
  export type RejectPerOperation = {
    [P in 'findUnique' | 'findFirst']?: RejectPerModel | RejectOnNotFound;
  };
  type IsReject<T> = T extends true
    ? True
    : T extends (err: Error) => Error
    ? True
    : False;
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>;
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal';

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null.
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation;
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources;

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>;
  }

  export type Hooks = {
    beforeRequest?: (options: {
      query: string;
      path: string[];
      rootField?: string;
      typeName?: string;
      document: any;
    }) => any;
  };

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error';
  export type LogDefinition = {
    level: LogLevel;
    emit: 'stdout' | 'event';
  };

  export type GetLogType<T extends LogLevel | LogDefinition> =
    T extends LogDefinition
      ? T['emit'] extends 'event'
        ? T['level']
        : never
      : never;
  export type GetEvents<T extends any> = T extends Array<
    LogLevel | LogDefinition
  >
    ? GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw';

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName;
    action: PrismaAction;
    args: any;
    dataPath: string[];
    runInTransaction: boolean;
  };

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>
  ) => Promise<T>;

  // tested in getLogLevel.test.ts
  export function getLogLevel(
    log: Array<LogLevel | LogDefinition>
  ): LogLevel | undefined;
  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    Token: number;
  };

  export type UserCountOutputTypeSelect = {
    Token?: boolean;
  };

  export type UserCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UserCountOutputTypeArgs,
    U = keyof S
  > = S extends true
    ? UserCountOutputType
    : S extends undefined
    ? never
    : S extends UserCountOutputTypeArgs
    ? 'include' extends U
      ? UserCountOutputType
      : 'select' extends U
      ? {
          [P in TrueKeys<S['select']>]: P extends keyof UserCountOutputType
            ? UserCountOutputType[P]
            : never;
        }
      : UserCountOutputType
    : UserCountOutputType;

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     *
     **/
    select?: UserCountOutputTypeSelect | null;
  };

  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    User: number;
  };

  export type RoleCountOutputTypeSelect = {
    User?: boolean;
  };

  export type RoleCountOutputTypeGetPayload<
    S extends boolean | null | undefined | RoleCountOutputTypeArgs,
    U = keyof S
  > = S extends true
    ? RoleCountOutputType
    : S extends undefined
    ? never
    : S extends RoleCountOutputTypeArgs
    ? 'include' extends U
      ? RoleCountOutputType
      : 'select' extends U
      ? {
          [P in TrueKeys<S['select']>]: P extends keyof RoleCountOutputType
            ? RoleCountOutputType[P]
            : never;
        }
      : RoleCountOutputType
    : RoleCountOutputType;

  // Custom InputTypes

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     *
     **/
    select?: RoleCountOutputTypeSelect | null;
  };

  /**
   * Count Type AddressCountOutputType
   */

  export type AddressCountOutputType = {
    User: number;
    Restaurant: number;
  };

  export type AddressCountOutputTypeSelect = {
    User?: boolean;
    Restaurant?: boolean;
  };

  export type AddressCountOutputTypeGetPayload<
    S extends boolean | null | undefined | AddressCountOutputTypeArgs,
    U = keyof S
  > = S extends true
    ? AddressCountOutputType
    : S extends undefined
    ? never
    : S extends AddressCountOutputTypeArgs
    ? 'include' extends U
      ? AddressCountOutputType
      : 'select' extends U
      ? {
          [P in TrueKeys<S['select']>]: P extends keyof AddressCountOutputType
            ? AddressCountOutputType[P]
            : never;
        }
      : AddressCountOutputType
    : AddressCountOutputType;

  // Custom InputTypes

  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the AddressCountOutputType
     *
     **/
    select?: AddressCountOutputTypeSelect | null;
  };

  /**
   * Count Type RestaurantCountOutputType
   */

  export type RestaurantCountOutputType = {
    RestaurantUser: number;
  };

  export type RestaurantCountOutputTypeSelect = {
    RestaurantUser?: boolean;
  };

  export type RestaurantCountOutputTypeGetPayload<
    S extends boolean | null | undefined | RestaurantCountOutputTypeArgs,
    U = keyof S
  > = S extends true
    ? RestaurantCountOutputType
    : S extends undefined
    ? never
    : S extends RestaurantCountOutputTypeArgs
    ? 'include' extends U
      ? RestaurantCountOutputType
      : 'select' extends U
      ? {
          [P in TrueKeys<
            S['select']
          >]: P extends keyof RestaurantCountOutputType
            ? RestaurantCountOutputType[P]
            : never;
        }
      : RestaurantCountOutputType
    : RestaurantCountOutputType;

  // Custom InputTypes

  /**
   * RestaurantCountOutputType without action
   */
  export type RestaurantCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RestaurantCountOutputType
     *
     **/
    select?: RestaurantCountOutputTypeSelect | null;
  };

  /**
   * Count Type RestauUserCountOutputType
   */

  export type RestauUserCountOutputType = {
    Token: number;
  };

  export type RestauUserCountOutputTypeSelect = {
    Token?: boolean;
  };

  export type RestauUserCountOutputTypeGetPayload<
    S extends boolean | null | undefined | RestauUserCountOutputTypeArgs,
    U = keyof S
  > = S extends true
    ? RestauUserCountOutputType
    : S extends undefined
    ? never
    : S extends RestauUserCountOutputTypeArgs
    ? 'include' extends U
      ? RestauUserCountOutputType
      : 'select' extends U
      ? {
          [P in TrueKeys<
            S['select']
          >]: P extends keyof RestauUserCountOutputType
            ? RestauUserCountOutputType[P]
            : never;
        }
      : RestauUserCountOutputType
    : RestauUserCountOutputType;

  // Custom InputTypes

  /**
   * RestauUserCountOutputType without action
   */
  export type RestauUserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RestauUserCountOutputType
     *
     **/
    select?: RestauUserCountOutputTypeSelect | null;
  };

  /**
   * Count Type RestauImagesCountOutputType
   */

  export type RestauImagesCountOutputType = {
    Restaurant: number;
    RestauUser: number;
  };

  export type RestauImagesCountOutputTypeSelect = {
    Restaurant?: boolean;
    RestauUser?: boolean;
  };

  export type RestauImagesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | RestauImagesCountOutputTypeArgs,
    U = keyof S
  > = S extends true
    ? RestauImagesCountOutputType
    : S extends undefined
    ? never
    : S extends RestauImagesCountOutputTypeArgs
    ? 'include' extends U
      ? RestauImagesCountOutputType
      : 'select' extends U
      ? {
          [P in TrueKeys<
            S['select']
          >]: P extends keyof RestauImagesCountOutputType
            ? RestauImagesCountOutputType[P]
            : never;
        }
      : RestauImagesCountOutputType
    : RestauImagesCountOutputType;

  // Custom InputTypes

  /**
   * RestauImagesCountOutputType without action
   */
  export type RestauImagesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RestauImagesCountOutputType
     *
     **/
    select?: RestauImagesCountOutputTypeSelect | null;
  };

  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  export type UserMinAggregateOutputType = {
    userId: string | null;
    phoneNumber: string | null;
    isPhoneConfirmed: boolean | null;
    username: string | null;
    password: string | null;
    completeName: string | null;
    userRoleId: string | null;
    userAddressId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type UserMaxAggregateOutputType = {
    userId: string | null;
    phoneNumber: string | null;
    isPhoneConfirmed: boolean | null;
    username: string | null;
    password: string | null;
    completeName: string | null;
    userRoleId: string | null;
    userAddressId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type UserCountAggregateOutputType = {
    userId: number;
    phoneNumber: number;
    isPhoneConfirmed: number;
    username: number;
    password: number;
    completeName: number;
    userRoleId: number;
    userAddressId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type UserMinAggregateInputType = {
    userId?: true;
    phoneNumber?: true;
    isPhoneConfirmed?: true;
    username?: true;
    password?: true;
    completeName?: true;
    userRoleId?: true;
    userAddressId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type UserMaxAggregateInputType = {
    userId?: true;
    phoneNumber?: true;
    isPhoneConfirmed?: true;
    username?: true;
    password?: true;
    completeName?: true;
    userRoleId?: true;
    userAddressId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type UserCountAggregateInputType = {
    userId?: true;
    phoneNumber?: true;
    isPhoneConfirmed?: true;
    username?: true;
    password?: true;
    completeName?: true;
    userRoleId?: true;
    userAddressId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     *
     **/
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     *
     **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     *
     **/
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     *
     **/
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     *
     **/
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Users
     **/
    _count?: true | UserCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserMaxAggregateInputType;
  };

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>;
  };

  export type UserGroupByArgs = {
    where?: UserWhereInput;
    orderBy?: Enumerable<UserOrderByWithAggregationInput>;
    by: Array<UserScalarFieldEnum>;
    having?: UserScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserCountAggregateInputType | true;
    _min?: UserMinAggregateInputType;
    _max?: UserMaxAggregateInputType;
  };

  export type UserGroupByOutputType = {
    userId: string;
    phoneNumber: string;
    isPhoneConfirmed: boolean;
    username: string;
    password: string;
    completeName: string | null;
    userRoleId: string;
    userAddressId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Promise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> & {
        [P in keyof T & keyof UserGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], UserGroupByOutputType[P]>
          : GetScalarType<T[P], UserGroupByOutputType[P]>;
      }
    >
  >;

  export type UserSelect = {
    userId?: boolean;
    phoneNumber?: boolean;
    isPhoneConfirmed?: boolean;
    username?: boolean;
    password?: boolean;
    completeName?: boolean;
    Role?: boolean | RoleArgs;
    Token?: boolean | TokensFindManyArgs;
    UserAddress?: boolean | AddressArgs;
    userRoleId?: boolean;
    userAddressId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    _count?: boolean | UserCountOutputTypeArgs;
  };

  export type UserInclude = {
    Role?: boolean | RoleArgs;
    Token?: boolean | TokensFindManyArgs;
    UserAddress?: boolean | AddressArgs;
    _count?: boolean | UserCountOutputTypeArgs;
  };

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
  > = S extends true
    ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ? 'include' extends U
      ? User & {
          [P in TrueKeys<S['include']>]: P extends 'Role'
            ? RoleGetPayload<S['include'][P]>
            : P extends 'Token'
            ? Array<TokensGetPayload<S['include'][P]>>
            : P extends 'UserAddress'
            ? AddressGetPayload<S['include'][P]> | null
            : P extends '_count'
            ? UserCountOutputTypeGetPayload<S['include'][P]>
            : never;
        }
      : 'select' extends U
      ? {
          [P in TrueKeys<S['select']>]: P extends keyof User
            ? User[P]
            : P extends 'Role'
            ? RoleGetPayload<S['select'][P]>
            : P extends 'Token'
            ? Array<TokensGetPayload<S['select'][P]>>
            : P extends 'UserAddress'
            ? AddressGetPayload<S['select'][P]> | null
            : P extends '_count'
            ? UserCountOutputTypeGetPayload<S['select'][P]>
            : never;
        }
      : User
    : User;

  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true;
    }
  >;

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUnique<
      T extends UserFindUniqueArgs,
      LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound
        ? T['rejectOnNotFound']
        : undefined
    >(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<
      GlobalRejectSettings,
      LocalRejectSettings,
      'findUnique',
      'User'
    > extends True
      ? CheckSelect<
          T,
          Prisma__UserClient<User>,
          Prisma__UserClient<UserGetPayload<T>>
        >
      : CheckSelect<
          T,
          Prisma__UserClient<User | null>,
          Prisma__UserClient<UserGetPayload<T> | null>
        >;

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirst<
      T extends UserFindFirstArgs,
      LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound
        ? T['rejectOnNotFound']
        : undefined
    >(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<
      GlobalRejectSettings,
      LocalRejectSettings,
      'findFirst',
      'User'
    > extends True
      ? CheckSelect<
          T,
          Prisma__UserClient<User>,
          Prisma__UserClient<UserGetPayload<T>>
        >
      : CheckSelect<
          T,
          Prisma__UserClient<User | null>,
          Prisma__UserClient<UserGetPayload<T> | null>
        >;

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     *
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     *
     * // Only select the `userId`
     * const userWithUserIdOnly = await prisma.user.findMany({ select: { userId: true } })
     *
     **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<
      T,
      PrismaPromise<Array<User>>,
      PrismaPromise<Array<UserGetPayload<T>>>
    >;

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     *
     **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<
      T,
      Prisma__UserClient<User>,
      Prisma__UserClient<UserGetPayload<T>>
    >;

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
     **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>;

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     *
     **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<
      T,
      Prisma__UserClient<User>,
      Prisma__UserClient<UserGetPayload<T>>
    >;

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<
      T,
      Prisma__UserClient<User>,
      Prisma__UserClient<UserGetPayload<T>>
    >;

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>;

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<
      T,
      Prisma__UserClient<User>,
      Prisma__UserClient<UserGetPayload<T>>
    >;

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
     **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserAggregateArgs>(
      args: Subset<T, UserAggregateArgs>
    ): PrismaPromise<GetUserAggregateType<T>>;

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  'Field ',
                  P,
                  ` in "having" needs to be provided in "by"`
                ];
          }[HavingFields]
        : 'take' extends Keys<T>
        ? 'orderBy' extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : 'skip' extends Keys<T>
        ? 'orderBy' extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "skip", you also need to provide "orderBy"'
        : ByValid extends True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
          }[OrderFields]
    >(
      args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetUserGroupByPayload<T> : Promise<InputErrors>;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(
      _dmmf: runtime.DMMFClass,
      _fetcher: PrismaClientFetcher,
      _queryType: 'query' | 'mutation',
      _rootField: string,
      _clientMethod: string,
      _args: any,
      _dataPath: string[],
      _errorFormat: ErrorFormat,
      _measurePerformance?: boolean | undefined,
      _isList?: boolean
    );
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Role<T extends RoleArgs = {}>(
      args?: Subset<T, RoleArgs>
    ): CheckSelect<
      T,
      Prisma__RoleClient<Role | null>,
      Prisma__RoleClient<RoleGetPayload<T> | null>
    >;

    Token<T extends TokensFindManyArgs = {}>(
      args?: Subset<T, TokensFindManyArgs>
    ): CheckSelect<
      T,
      PrismaPromise<Array<Tokens>>,
      PrismaPromise<Array<TokensGetPayload<T>>>
    >;

    UserAddress<T extends AddressArgs = {}>(
      args?: Subset<T, AddressArgs>
    ): CheckSelect<
      T,
      Prisma__AddressClient<Address | null>,
      Prisma__AddressClient<AddressGetPayload<T> | null>
    >;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the User
     *
     **/
    select?: UserSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: UserInclude | null;
    /**
     * Throw an Error if a User can't be found
     *
     **/
    rejectOnNotFound?: RejectOnNotFound;
    /**
     * Filter, which User to fetch.
     *
     **/
    where: UserWhereUniqueInput;
  };

  /**
   * User findFirst
   */
  export type UserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the User
     *
     **/
    select?: UserSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: UserInclude | null;
    /**
     * Throw an Error if a User can't be found
     *
     **/
    rejectOnNotFound?: RejectOnNotFound;
    /**
     * Filter, which User to fetch.
     *
     **/
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     *
     **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     *
     **/
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     *
     **/
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     *
     **/
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     *
     **/
    distinct?: Enumerable<UserScalarFieldEnum>;
  };

  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     *
     **/
    select?: UserSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: UserInclude | null;
    /**
     * Filter, which Users to fetch.
     *
     **/
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     *
     **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Users.
     *
     **/
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     *
     **/
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     *
     **/
    skip?: number;
    distinct?: Enumerable<UserScalarFieldEnum>;
  };

  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     *
     **/
    select?: UserSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: UserInclude | null;
    /**
     * The data needed to create a User.
     *
     **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>;
  };

  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     *
     **/
    data: Enumerable<UserCreateManyInput>;
    skipDuplicates?: boolean;
  };

  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     *
     **/
    select?: UserSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: UserInclude | null;
    /**
     * The data needed to update a User.
     *
     **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
    /**
     * Choose, which User to update.
     *
     **/
    where: UserWhereUniqueInput;
  };

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     *
     **/
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     *
     **/
    where?: UserWhereInput;
  };

  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     *
     **/
    select?: UserSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: UserInclude | null;
    /**
     * The filter to search for the User to update in case it exists.
     *
     **/
    where: UserWhereUniqueInput;
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     *
     **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>;
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     *
     **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
  };

  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     *
     **/
    select?: UserSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: UserInclude | null;
    /**
     * Filter which User to delete.
     *
     **/
    where: UserWhereUniqueInput;
  };

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     *
     **/
    where?: UserWhereInput;
  };

  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     *
     **/
    select?: UserSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: UserInclude | null;
  };

  /**
   * Model Tokens
   */

  export type AggregateTokens = {
    _count: TokensCountAggregateOutputType | null;
    _min: TokensMinAggregateOutputType | null;
    _max: TokensMaxAggregateOutputType | null;
  };

  export type TokensMinAggregateOutputType = {
    tokenId: string | null;
    token: string | null;
    userId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type TokensMaxAggregateOutputType = {
    tokenId: string | null;
    token: string | null;
    userId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type TokensCountAggregateOutputType = {
    tokenId: number;
    token: number;
    userId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type TokensMinAggregateInputType = {
    tokenId?: true;
    token?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type TokensMaxAggregateInputType = {
    tokenId?: true;
    token?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type TokensCountAggregateInputType = {
    tokenId?: true;
    token?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type TokensAggregateArgs = {
    /**
     * Filter which Tokens to aggregate.
     *
     **/
    where?: TokensWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Tokens to fetch.
     *
     **/
    orderBy?: Enumerable<TokensOrderByWithRelationInput>;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     *
     **/
    cursor?: TokensWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Tokens from the position of the cursor.
     *
     **/
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Tokens.
     *
     **/
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Tokens
     **/
    _count?: true | TokensCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: TokensMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: TokensMaxAggregateInputType;
  };

  export type GetTokensAggregateType<T extends TokensAggregateArgs> = {
    [P in keyof T & keyof AggregateTokens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTokens[P]>
      : GetScalarType<T[P], AggregateTokens[P]>;
  };

  export type TokensGroupByArgs = {
    where?: TokensWhereInput;
    orderBy?: Enumerable<TokensOrderByWithAggregationInput>;
    by: Array<TokensScalarFieldEnum>;
    having?: TokensScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: TokensCountAggregateInputType | true;
    _min?: TokensMinAggregateInputType;
    _max?: TokensMaxAggregateInputType;
  };

  export type TokensGroupByOutputType = {
    tokenId: string;
    token: string;
    userId: string;
    createdAt: Date | null;
    updatedAt: Date | null;
    _count: TokensCountAggregateOutputType | null;
    _min: TokensMinAggregateOutputType | null;
    _max: TokensMaxAggregateOutputType | null;
  };

  type GetTokensGroupByPayload<T extends TokensGroupByArgs> = Promise<
    Array<
      PickArray<TokensGroupByOutputType, T['by']> & {
        [P in keyof T & keyof TokensGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], TokensGroupByOutputType[P]>
          : GetScalarType<T[P], TokensGroupByOutputType[P]>;
      }
    >
  >;

  export type TokensSelect = {
    tokenId?: boolean;
    token?: boolean;
    userId?: boolean;
    User?: boolean | UserArgs;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type TokensInclude = {
    User?: boolean | UserArgs;
  };

  export type TokensGetPayload<
    S extends boolean | null | undefined | TokensArgs,
    U = keyof S
  > = S extends true
    ? Tokens
    : S extends undefined
    ? never
    : S extends TokensArgs | TokensFindManyArgs
    ? 'include' extends U
      ? Tokens & {
          [P in TrueKeys<S['include']>]: P extends 'User'
            ? UserGetPayload<S['include'][P]>
            : never;
        }
      : 'select' extends U
      ? {
          [P in TrueKeys<S['select']>]: P extends keyof Tokens
            ? Tokens[P]
            : P extends 'User'
            ? UserGetPayload<S['select'][P]>
            : never;
        }
      : Tokens
    : Tokens;

  type TokensCountArgs = Merge<
    Omit<TokensFindManyArgs, 'select' | 'include'> & {
      select?: TokensCountAggregateInputType | true;
    }
  >;

  export interface TokensDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Tokens that matches the filter.
     * @param {TokensFindUniqueArgs} args - Arguments to find a Tokens
     * @example
     * // Get one Tokens
     * const tokens = await prisma.tokens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUnique<
      T extends TokensFindUniqueArgs,
      LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound
        ? T['rejectOnNotFound']
        : undefined
    >(
      args: SelectSubset<T, TokensFindUniqueArgs>
    ): HasReject<
      GlobalRejectSettings,
      LocalRejectSettings,
      'findUnique',
      'Tokens'
    > extends True
      ? CheckSelect<
          T,
          Prisma__TokensClient<Tokens>,
          Prisma__TokensClient<TokensGetPayload<T>>
        >
      : CheckSelect<
          T,
          Prisma__TokensClient<Tokens | null>,
          Prisma__TokensClient<TokensGetPayload<T> | null>
        >;

    /**
     * Find the first Tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokensFindFirstArgs} args - Arguments to find a Tokens
     * @example
     * // Get one Tokens
     * const tokens = await prisma.tokens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirst<
      T extends TokensFindFirstArgs,
      LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound
        ? T['rejectOnNotFound']
        : undefined
    >(
      args?: SelectSubset<T, TokensFindFirstArgs>
    ): HasReject<
      GlobalRejectSettings,
      LocalRejectSettings,
      'findFirst',
      'Tokens'
    > extends True
      ? CheckSelect<
          T,
          Prisma__TokensClient<Tokens>,
          Prisma__TokensClient<TokensGetPayload<T>>
        >
      : CheckSelect<
          T,
          Prisma__TokensClient<Tokens | null>,
          Prisma__TokensClient<TokensGetPayload<T> | null>
        >;

    /**
     * Find zero or more Tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokensFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tokens
     * const tokens = await prisma.tokens.findMany()
     *
     * // Get first 10 Tokens
     * const tokens = await prisma.tokens.findMany({ take: 10 })
     *
     * // Only select the `tokenId`
     * const tokensWithTokenIdOnly = await prisma.tokens.findMany({ select: { tokenId: true } })
     *
     **/
    findMany<T extends TokensFindManyArgs>(
      args?: SelectSubset<T, TokensFindManyArgs>
    ): CheckSelect<
      T,
      PrismaPromise<Array<Tokens>>,
      PrismaPromise<Array<TokensGetPayload<T>>>
    >;

    /**
     * Create a Tokens.
     * @param {TokensCreateArgs} args - Arguments to create a Tokens.
     * @example
     * // Create one Tokens
     * const Tokens = await prisma.tokens.create({
     *   data: {
     *     // ... data to create a Tokens
     *   }
     * })
     *
     **/
    create<T extends TokensCreateArgs>(
      args: SelectSubset<T, TokensCreateArgs>
    ): CheckSelect<
      T,
      Prisma__TokensClient<Tokens>,
      Prisma__TokensClient<TokensGetPayload<T>>
    >;

    /**
     * Create many Tokens.
     *     @param {TokensCreateManyArgs} args - Arguments to create many Tokens.
     *     @example
     *     // Create many Tokens
     *     const tokens = await prisma.tokens.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
     **/
    createMany<T extends TokensCreateManyArgs>(
      args?: SelectSubset<T, TokensCreateManyArgs>
    ): PrismaPromise<BatchPayload>;

    /**
     * Delete a Tokens.
     * @param {TokensDeleteArgs} args - Arguments to delete one Tokens.
     * @example
     * // Delete one Tokens
     * const Tokens = await prisma.tokens.delete({
     *   where: {
     *     // ... filter to delete one Tokens
     *   }
     * })
     *
     **/
    delete<T extends TokensDeleteArgs>(
      args: SelectSubset<T, TokensDeleteArgs>
    ): CheckSelect<
      T,
      Prisma__TokensClient<Tokens>,
      Prisma__TokensClient<TokensGetPayload<T>>
    >;

    /**
     * Update one Tokens.
     * @param {TokensUpdateArgs} args - Arguments to update one Tokens.
     * @example
     * // Update one Tokens
     * const tokens = await prisma.tokens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    update<T extends TokensUpdateArgs>(
      args: SelectSubset<T, TokensUpdateArgs>
    ): CheckSelect<
      T,
      Prisma__TokensClient<Tokens>,
      Prisma__TokensClient<TokensGetPayload<T>>
    >;

    /**
     * Delete zero or more Tokens.
     * @param {TokensDeleteManyArgs} args - Arguments to filter Tokens to delete.
     * @example
     * // Delete a few Tokens
     * const { count } = await prisma.tokens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     **/
    deleteMany<T extends TokensDeleteManyArgs>(
      args?: SelectSubset<T, TokensDeleteManyArgs>
    ): PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tokens
     * const tokens = await prisma.tokens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    updateMany<T extends TokensUpdateManyArgs>(
      args: SelectSubset<T, TokensUpdateManyArgs>
    ): PrismaPromise<BatchPayload>;

    /**
     * Create or update one Tokens.
     * @param {TokensUpsertArgs} args - Arguments to update or create a Tokens.
     * @example
     * // Update or create a Tokens
     * const tokens = await prisma.tokens.upsert({
     *   create: {
     *     // ... data to create a Tokens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tokens we want to update
     *   }
     * })
     **/
    upsert<T extends TokensUpsertArgs>(
      args: SelectSubset<T, TokensUpsertArgs>
    ): CheckSelect<
      T,
      Prisma__TokensClient<Tokens>,
      Prisma__TokensClient<TokensGetPayload<T>>
    >;

    /**
     * Count the number of Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokensCountArgs} args - Arguments to filter Tokens to count.
     * @example
     * // Count the number of Tokens
     * const count = await prisma.tokens.count({
     *   where: {
     *     // ... the filter for the Tokens we want to count
     *   }
     * })
     **/
    count<T extends TokensCountArgs>(
      args?: Subset<T, TokensCountArgs>
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokensCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends TokensAggregateArgs>(
      args: Subset<T, TokensAggregateArgs>
    ): PrismaPromise<GetTokensAggregateType<T>>;

    /**
     * Group by Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends TokensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokensGroupByArgs['orderBy'] }
        : { orderBy?: TokensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  'Field ',
                  P,
                  ` in "having" needs to be provided in "by"`
                ];
          }[HavingFields]
        : 'take' extends Keys<T>
        ? 'orderBy' extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : 'skip' extends Keys<T>
        ? 'orderBy' extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "skip", you also need to provide "orderBy"'
        : ByValid extends True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
          }[OrderFields]
    >(
      args: SubsetIntersection<T, TokensGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetTokensGroupByPayload<T>
      : Promise<InputErrors>;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tokens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TokensClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(
      _dmmf: runtime.DMMFClass,
      _fetcher: PrismaClientFetcher,
      _queryType: 'query' | 'mutation',
      _rootField: string,
      _clientMethod: string,
      _args: any,
      _dataPath: string[],
      _errorFormat: ErrorFormat,
      _measurePerformance?: boolean | undefined,
      _isList?: boolean
    );
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserArgs = {}>(
      args?: Subset<T, UserArgs>
    ): CheckSelect<
      T,
      Prisma__UserClient<User | null>,
      Prisma__UserClient<UserGetPayload<T> | null>
    >;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Tokens findUnique
   */
  export type TokensFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Tokens
     *
     **/
    select?: TokensSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: TokensInclude | null;
    /**
     * Throw an Error if a Tokens can't be found
     *
     **/
    rejectOnNotFound?: RejectOnNotFound;
    /**
     * Filter, which Tokens to fetch.
     *
     **/
    where: TokensWhereUniqueInput;
  };

  /**
   * Tokens findFirst
   */
  export type TokensFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Tokens
     *
     **/
    select?: TokensSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: TokensInclude | null;
    /**
     * Throw an Error if a Tokens can't be found
     *
     **/
    rejectOnNotFound?: RejectOnNotFound;
    /**
     * Filter, which Tokens to fetch.
     *
     **/
    where?: TokensWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Tokens to fetch.
     *
     **/
    orderBy?: Enumerable<TokensOrderByWithRelationInput>;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Tokens.
     *
     **/
    cursor?: TokensWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Tokens from the position of the cursor.
     *
     **/
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Tokens.
     *
     **/
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Tokens.
     *
     **/
    distinct?: Enumerable<TokensScalarFieldEnum>;
  };

  /**
   * Tokens findMany
   */
  export type TokensFindManyArgs = {
    /**
     * Select specific fields to fetch from the Tokens
     *
     **/
    select?: TokensSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: TokensInclude | null;
    /**
     * Filter, which Tokens to fetch.
     *
     **/
    where?: TokensWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Tokens to fetch.
     *
     **/
    orderBy?: Enumerable<TokensOrderByWithRelationInput>;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Tokens.
     *
     **/
    cursor?: TokensWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Tokens from the position of the cursor.
     *
     **/
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Tokens.
     *
     **/
    skip?: number;
    distinct?: Enumerable<TokensScalarFieldEnum>;
  };

  /**
   * Tokens create
   */
  export type TokensCreateArgs = {
    /**
     * Select specific fields to fetch from the Tokens
     *
     **/
    select?: TokensSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: TokensInclude | null;
    /**
     * The data needed to create a Tokens.
     *
     **/
    data: XOR<TokensCreateInput, TokensUncheckedCreateInput>;
  };

  /**
   * Tokens createMany
   */
  export type TokensCreateManyArgs = {
    /**
     * The data used to create many Tokens.
     *
     **/
    data: Enumerable<TokensCreateManyInput>;
    skipDuplicates?: boolean;
  };

  /**
   * Tokens update
   */
  export type TokensUpdateArgs = {
    /**
     * Select specific fields to fetch from the Tokens
     *
     **/
    select?: TokensSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: TokensInclude | null;
    /**
     * The data needed to update a Tokens.
     *
     **/
    data: XOR<TokensUpdateInput, TokensUncheckedUpdateInput>;
    /**
     * Choose, which Tokens to update.
     *
     **/
    where: TokensWhereUniqueInput;
  };

  /**
   * Tokens updateMany
   */
  export type TokensUpdateManyArgs = {
    /**
     * The data used to update Tokens.
     *
     **/
    data: XOR<TokensUpdateManyMutationInput, TokensUncheckedUpdateManyInput>;
    /**
     * Filter which Tokens to update
     *
     **/
    where?: TokensWhereInput;
  };

  /**
   * Tokens upsert
   */
  export type TokensUpsertArgs = {
    /**
     * Select specific fields to fetch from the Tokens
     *
     **/
    select?: TokensSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: TokensInclude | null;
    /**
     * The filter to search for the Tokens to update in case it exists.
     *
     **/
    where: TokensWhereUniqueInput;
    /**
     * In case the Tokens found by the `where` argument doesn't exist, create a new Tokens with this data.
     *
     **/
    create: XOR<TokensCreateInput, TokensUncheckedCreateInput>;
    /**
     * In case the Tokens was found with the provided `where` argument, update it with this data.
     *
     **/
    update: XOR<TokensUpdateInput, TokensUncheckedUpdateInput>;
  };

  /**
   * Tokens delete
   */
  export type TokensDeleteArgs = {
    /**
     * Select specific fields to fetch from the Tokens
     *
     **/
    select?: TokensSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: TokensInclude | null;
    /**
     * Filter which Tokens to delete.
     *
     **/
    where: TokensWhereUniqueInput;
  };

  /**
   * Tokens deleteMany
   */
  export type TokensDeleteManyArgs = {
    /**
     * Filter which Tokens to delete
     *
     **/
    where?: TokensWhereInput;
  };

  /**
   * Tokens without action
   */
  export type TokensArgs = {
    /**
     * Select specific fields to fetch from the Tokens
     *
     **/
    select?: TokensSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: TokensInclude | null;
  };

  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null;
    _min: RoleMinAggregateOutputType | null;
    _max: RoleMaxAggregateOutputType | null;
  };

  export type RoleMinAggregateOutputType = {
    roleId: string | null;
    userRole: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type RoleMaxAggregateOutputType = {
    roleId: string | null;
    userRole: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type RoleCountAggregateOutputType = {
    roleId: number;
    userRole: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type RoleMinAggregateInputType = {
    roleId?: true;
    userRole?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type RoleMaxAggregateInputType = {
    roleId?: true;
    userRole?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type RoleCountAggregateInputType = {
    roleId?: true;
    userRole?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type RoleAggregateArgs = {
    /**
     * Filter which Role to aggregate.
     *
     **/
    where?: RoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Roles to fetch.
     *
     **/
    orderBy?: Enumerable<RoleOrderByWithRelationInput>;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     *
     **/
    cursor?: RoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Roles from the position of the cursor.
     *
     **/
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Roles.
     *
     **/
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Roles
     **/
    _count?: true | RoleCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: RoleMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: RoleMaxAggregateInputType;
  };

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
    [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>;
  };

  export type RoleGroupByArgs = {
    where?: RoleWhereInput;
    orderBy?: Enumerable<RoleOrderByWithAggregationInput>;
    by: Array<RoleScalarFieldEnum>;
    having?: RoleScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: RoleCountAggregateInputType | true;
    _min?: RoleMinAggregateInputType;
    _max?: RoleMaxAggregateInputType;
  };

  export type RoleGroupByOutputType = {
    roleId: string;
    userRole: string;
    createdAt: Date | null;
    updatedAt: Date | null;
    _count: RoleCountAggregateOutputType | null;
    _min: RoleMinAggregateOutputType | null;
    _max: RoleMaxAggregateOutputType | null;
  };

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Promise<
    Array<
      PickArray<RoleGroupByOutputType, T['by']> & {
        [P in keyof T & keyof RoleGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
          : GetScalarType<T[P], RoleGroupByOutputType[P]>;
      }
    >
  >;

  export type RoleSelect = {
    roleId?: boolean;
    userRole?: boolean;
    User?: boolean | UserFindManyArgs;
    createdAt?: boolean;
    updatedAt?: boolean;
    _count?: boolean | RoleCountOutputTypeArgs;
  };

  export type RoleInclude = {
    User?: boolean | UserFindManyArgs;
    _count?: boolean | RoleCountOutputTypeArgs;
  };

  export type RoleGetPayload<
    S extends boolean | null | undefined | RoleArgs,
    U = keyof S
  > = S extends true
    ? Role
    : S extends undefined
    ? never
    : S extends RoleArgs | RoleFindManyArgs
    ? 'include' extends U
      ? Role & {
          [P in TrueKeys<S['include']>]: P extends 'User'
            ? Array<UserGetPayload<S['include'][P]>>
            : P extends '_count'
            ? RoleCountOutputTypeGetPayload<S['include'][P]>
            : never;
        }
      : 'select' extends U
      ? {
          [P in TrueKeys<S['select']>]: P extends keyof Role
            ? Role[P]
            : P extends 'User'
            ? Array<UserGetPayload<S['select'][P]>>
            : P extends '_count'
            ? RoleCountOutputTypeGetPayload<S['select'][P]>
            : never;
        }
      : Role
    : Role;

  type RoleCountArgs = Merge<
    Omit<RoleFindManyArgs, 'select' | 'include'> & {
      select?: RoleCountAggregateInputType | true;
    }
  >;

  export interface RoleDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUnique<
      T extends RoleFindUniqueArgs,
      LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound
        ? T['rejectOnNotFound']
        : undefined
    >(
      args: SelectSubset<T, RoleFindUniqueArgs>
    ): HasReject<
      GlobalRejectSettings,
      LocalRejectSettings,
      'findUnique',
      'Role'
    > extends True
      ? CheckSelect<
          T,
          Prisma__RoleClient<Role>,
          Prisma__RoleClient<RoleGetPayload<T>>
        >
      : CheckSelect<
          T,
          Prisma__RoleClient<Role | null>,
          Prisma__RoleClient<RoleGetPayload<T> | null>
        >;

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirst<
      T extends RoleFindFirstArgs,
      LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound
        ? T['rejectOnNotFound']
        : undefined
    >(
      args?: SelectSubset<T, RoleFindFirstArgs>
    ): HasReject<
      GlobalRejectSettings,
      LocalRejectSettings,
      'findFirst',
      'Role'
    > extends True
      ? CheckSelect<
          T,
          Prisma__RoleClient<Role>,
          Prisma__RoleClient<RoleGetPayload<T>>
        >
      : CheckSelect<
          T,
          Prisma__RoleClient<Role | null>,
          Prisma__RoleClient<RoleGetPayload<T> | null>
        >;

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     *
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     *
     * // Only select the `roleId`
     * const roleWithRoleIdOnly = await prisma.role.findMany({ select: { roleId: true } })
     *
     **/
    findMany<T extends RoleFindManyArgs>(
      args?: SelectSubset<T, RoleFindManyArgs>
    ): CheckSelect<
      T,
      PrismaPromise<Array<Role>>,
      PrismaPromise<Array<RoleGetPayload<T>>>
    >;

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     *
     **/
    create<T extends RoleCreateArgs>(
      args: SelectSubset<T, RoleCreateArgs>
    ): CheckSelect<
      T,
      Prisma__RoleClient<Role>,
      Prisma__RoleClient<RoleGetPayload<T>>
    >;

    /**
     * Create many Roles.
     *     @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     *     @example
     *     // Create many Roles
     *     const role = await prisma.role.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
     **/
    createMany<T extends RoleCreateManyArgs>(
      args?: SelectSubset<T, RoleCreateManyArgs>
    ): PrismaPromise<BatchPayload>;

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     *
     **/
    delete<T extends RoleDeleteArgs>(
      args: SelectSubset<T, RoleDeleteArgs>
    ): CheckSelect<
      T,
      Prisma__RoleClient<Role>,
      Prisma__RoleClient<RoleGetPayload<T>>
    >;

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    update<T extends RoleUpdateArgs>(
      args: SelectSubset<T, RoleUpdateArgs>
    ): CheckSelect<
      T,
      Prisma__RoleClient<Role>,
      Prisma__RoleClient<RoleGetPayload<T>>
    >;

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     **/
    deleteMany<T extends RoleDeleteManyArgs>(
      args?: SelectSubset<T, RoleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    updateMany<T extends RoleUpdateManyArgs>(
      args: SelectSubset<T, RoleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>;

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     **/
    upsert<T extends RoleUpsertArgs>(
      args: SelectSubset<T, RoleUpsertArgs>
    ): CheckSelect<
      T,
      Prisma__RoleClient<Role>,
      Prisma__RoleClient<RoleGetPayload<T>>
    >;

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
     **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends RoleAggregateArgs>(
      args: Subset<T, RoleAggregateArgs>
    ): PrismaPromise<GetRoleAggregateType<T>>;

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  'Field ',
                  P,
                  ` in "having" needs to be provided in "by"`
                ];
          }[HavingFields]
        : 'take' extends Keys<T>
        ? 'orderBy' extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : 'skip' extends Keys<T>
        ? 'orderBy' extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "skip", you also need to provide "orderBy"'
        : ByValid extends True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
          }[OrderFields]
    >(
      args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetRoleGroupByPayload<T> : Promise<InputErrors>;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RoleClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(
      _dmmf: runtime.DMMFClass,
      _fetcher: PrismaClientFetcher,
      _queryType: 'query' | 'mutation',
      _rootField: string,
      _clientMethod: string,
      _args: any,
      _dataPath: string[],
      _errorFormat: ErrorFormat,
      _measurePerformance?: boolean | undefined,
      _isList?: boolean
    );
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserFindManyArgs = {}>(
      args?: Subset<T, UserFindManyArgs>
    ): CheckSelect<
      T,
      PrismaPromise<Array<User>>,
      PrismaPromise<Array<UserGetPayload<T>>>
    >;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Role
     *
     **/
    select?: RoleSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RoleInclude | null;
    /**
     * Throw an Error if a Role can't be found
     *
     **/
    rejectOnNotFound?: RejectOnNotFound;
    /**
     * Filter, which Role to fetch.
     *
     **/
    where: RoleWhereUniqueInput;
  };

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Role
     *
     **/
    select?: RoleSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RoleInclude | null;
    /**
     * Throw an Error if a Role can't be found
     *
     **/
    rejectOnNotFound?: RejectOnNotFound;
    /**
     * Filter, which Role to fetch.
     *
     **/
    where?: RoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Roles to fetch.
     *
     **/
    orderBy?: Enumerable<RoleOrderByWithRelationInput>;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Roles.
     *
     **/
    cursor?: RoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Roles from the position of the cursor.
     *
     **/
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Roles.
     *
     **/
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Roles.
     *
     **/
    distinct?: Enumerable<RoleScalarFieldEnum>;
  };

  /**
   * Role findMany
   */
  export type RoleFindManyArgs = {
    /**
     * Select specific fields to fetch from the Role
     *
     **/
    select?: RoleSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RoleInclude | null;
    /**
     * Filter, which Roles to fetch.
     *
     **/
    where?: RoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Roles to fetch.
     *
     **/
    orderBy?: Enumerable<RoleOrderByWithRelationInput>;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Roles.
     *
     **/
    cursor?: RoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Roles from the position of the cursor.
     *
     **/
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Roles.
     *
     **/
    skip?: number;
    distinct?: Enumerable<RoleScalarFieldEnum>;
  };

  /**
   * Role create
   */
  export type RoleCreateArgs = {
    /**
     * Select specific fields to fetch from the Role
     *
     **/
    select?: RoleSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RoleInclude | null;
    /**
     * The data needed to create a Role.
     *
     **/
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>;
  };

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs = {
    /**
     * The data used to create many Roles.
     *
     **/
    data: Enumerable<RoleCreateManyInput>;
    skipDuplicates?: boolean;
  };

  /**
   * Role update
   */
  export type RoleUpdateArgs = {
    /**
     * Select specific fields to fetch from the Role
     *
     **/
    select?: RoleSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RoleInclude | null;
    /**
     * The data needed to update a Role.
     *
     **/
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>;
    /**
     * Choose, which Role to update.
     *
     **/
    where: RoleWhereUniqueInput;
  };

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs = {
    /**
     * The data used to update Roles.
     *
     **/
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>;
    /**
     * Filter which Roles to update
     *
     **/
    where?: RoleWhereInput;
  };

  /**
   * Role upsert
   */
  export type RoleUpsertArgs = {
    /**
     * Select specific fields to fetch from the Role
     *
     **/
    select?: RoleSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RoleInclude | null;
    /**
     * The filter to search for the Role to update in case it exists.
     *
     **/
    where: RoleWhereUniqueInput;
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     *
     **/
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>;
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     *
     **/
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>;
  };

  /**
   * Role delete
   */
  export type RoleDeleteArgs = {
    /**
     * Select specific fields to fetch from the Role
     *
     **/
    select?: RoleSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RoleInclude | null;
    /**
     * Filter which Role to delete.
     *
     **/
    where: RoleWhereUniqueInput;
  };

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs = {
    /**
     * Filter which Roles to delete
     *
     **/
    where?: RoleWhereInput;
  };

  /**
   * Role without action
   */
  export type RoleArgs = {
    /**
     * Select specific fields to fetch from the Role
     *
     **/
    select?: RoleSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RoleInclude | null;
  };

  /**
   * Model Address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null;
    _min: AddressMinAggregateOutputType | null;
    _max: AddressMaxAggregateOutputType | null;
  };

  export type AddressMinAggregateOutputType = {
    addressId: string | null;
    commune: string | null;
    address: string | null;
    longitude: string | null;
    latitude: string | null;
    restauId: string | null;
    userId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type AddressMaxAggregateOutputType = {
    addressId: string | null;
    commune: string | null;
    address: string | null;
    longitude: string | null;
    latitude: string | null;
    restauId: string | null;
    userId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type AddressCountAggregateOutputType = {
    addressId: number;
    commune: number;
    address: number;
    longitude: number;
    latitude: number;
    restauId: number;
    userId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type AddressMinAggregateInputType = {
    addressId?: true;
    commune?: true;
    address?: true;
    longitude?: true;
    latitude?: true;
    restauId?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type AddressMaxAggregateInputType = {
    addressId?: true;
    commune?: true;
    address?: true;
    longitude?: true;
    latitude?: true;
    restauId?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type AddressCountAggregateInputType = {
    addressId?: true;
    commune?: true;
    address?: true;
    longitude?: true;
    latitude?: true;
    restauId?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type AddressAggregateArgs = {
    /**
     * Filter which Address to aggregate.
     *
     **/
    where?: AddressWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Addresses to fetch.
     *
     **/
    orderBy?: Enumerable<AddressOrderByWithRelationInput>;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     *
     **/
    cursor?: AddressWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Addresses from the position of the cursor.
     *
     **/
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Addresses.
     *
     **/
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Addresses
     **/
    _count?: true | AddressCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AddressMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AddressMaxAggregateInputType;
  };

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
    [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>;
  };

  export type AddressGroupByArgs = {
    where?: AddressWhereInput;
    orderBy?: Enumerable<AddressOrderByWithAggregationInput>;
    by: Array<AddressScalarFieldEnum>;
    having?: AddressScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AddressCountAggregateInputType | true;
    _min?: AddressMinAggregateInputType;
    _max?: AddressMaxAggregateInputType;
  };

  export type AddressGroupByOutputType = {
    addressId: string;
    commune: string | null;
    address: string;
    longitude: string;
    latitude: string;
    restauId: string | null;
    userId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    _count: AddressCountAggregateOutputType | null;
    _min: AddressMinAggregateOutputType | null;
    _max: AddressMaxAggregateOutputType | null;
  };

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Promise<
    Array<
      PickArray<AddressGroupByOutputType, T['by']> & {
        [P in keyof T & keyof AddressGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
          : GetScalarType<T[P], AddressGroupByOutputType[P]>;
      }
    >
  >;

  export type AddressSelect = {
    addressId?: boolean;
    commune?: boolean;
    address?: boolean;
    longitude?: boolean;
    latitude?: boolean;
    restauId?: boolean;
    userId?: boolean;
    User?: boolean | UserFindManyArgs;
    Restaurant?: boolean | RestaurantFindManyArgs;
    createdAt?: boolean;
    updatedAt?: boolean;
    _count?: boolean | AddressCountOutputTypeArgs;
  };

  export type AddressInclude = {
    User?: boolean | UserFindManyArgs;
    Restaurant?: boolean | RestaurantFindManyArgs;
    _count?: boolean | AddressCountOutputTypeArgs;
  };

  export type AddressGetPayload<
    S extends boolean | null | undefined | AddressArgs,
    U = keyof S
  > = S extends true
    ? Address
    : S extends undefined
    ? never
    : S extends AddressArgs | AddressFindManyArgs
    ? 'include' extends U
      ? Address & {
          [P in TrueKeys<S['include']>]: P extends 'User'
            ? Array<UserGetPayload<S['include'][P]>>
            : P extends 'Restaurant'
            ? Array<RestaurantGetPayload<S['include'][P]>>
            : P extends '_count'
            ? AddressCountOutputTypeGetPayload<S['include'][P]>
            : never;
        }
      : 'select' extends U
      ? {
          [P in TrueKeys<S['select']>]: P extends keyof Address
            ? Address[P]
            : P extends 'User'
            ? Array<UserGetPayload<S['select'][P]>>
            : P extends 'Restaurant'
            ? Array<RestaurantGetPayload<S['select'][P]>>
            : P extends '_count'
            ? AddressCountOutputTypeGetPayload<S['select'][P]>
            : never;
        }
      : Address
    : Address;

  type AddressCountArgs = Merge<
    Omit<AddressFindManyArgs, 'select' | 'include'> & {
      select?: AddressCountAggregateInputType | true;
    }
  >;

  export interface AddressDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUnique<
      T extends AddressFindUniqueArgs,
      LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound
        ? T['rejectOnNotFound']
        : undefined
    >(
      args: SelectSubset<T, AddressFindUniqueArgs>
    ): HasReject<
      GlobalRejectSettings,
      LocalRejectSettings,
      'findUnique',
      'Address'
    > extends True
      ? CheckSelect<
          T,
          Prisma__AddressClient<Address>,
          Prisma__AddressClient<AddressGetPayload<T>>
        >
      : CheckSelect<
          T,
          Prisma__AddressClient<Address | null>,
          Prisma__AddressClient<AddressGetPayload<T> | null>
        >;

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirst<
      T extends AddressFindFirstArgs,
      LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound
        ? T['rejectOnNotFound']
        : undefined
    >(
      args?: SelectSubset<T, AddressFindFirstArgs>
    ): HasReject<
      GlobalRejectSettings,
      LocalRejectSettings,
      'findFirst',
      'Address'
    > extends True
      ? CheckSelect<
          T,
          Prisma__AddressClient<Address>,
          Prisma__AddressClient<AddressGetPayload<T>>
        >
      : CheckSelect<
          T,
          Prisma__AddressClient<Address | null>,
          Prisma__AddressClient<AddressGetPayload<T> | null>
        >;

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     *
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     *
     * // Only select the `addressId`
     * const addressWithAddressIdOnly = await prisma.address.findMany({ select: { addressId: true } })
     *
     **/
    findMany<T extends AddressFindManyArgs>(
      args?: SelectSubset<T, AddressFindManyArgs>
    ): CheckSelect<
      T,
      PrismaPromise<Array<Address>>,
      PrismaPromise<Array<AddressGetPayload<T>>>
    >;

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     *
     **/
    create<T extends AddressCreateArgs>(
      args: SelectSubset<T, AddressCreateArgs>
    ): CheckSelect<
      T,
      Prisma__AddressClient<Address>,
      Prisma__AddressClient<AddressGetPayload<T>>
    >;

    /**
     * Create many Addresses.
     *     @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     *     @example
     *     // Create many Addresses
     *     const address = await prisma.address.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
     **/
    createMany<T extends AddressCreateManyArgs>(
      args?: SelectSubset<T, AddressCreateManyArgs>
    ): PrismaPromise<BatchPayload>;

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     *
     **/
    delete<T extends AddressDeleteArgs>(
      args: SelectSubset<T, AddressDeleteArgs>
    ): CheckSelect<
      T,
      Prisma__AddressClient<Address>,
      Prisma__AddressClient<AddressGetPayload<T>>
    >;

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    update<T extends AddressUpdateArgs>(
      args: SelectSubset<T, AddressUpdateArgs>
    ): CheckSelect<
      T,
      Prisma__AddressClient<Address>,
      Prisma__AddressClient<AddressGetPayload<T>>
    >;

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     **/
    deleteMany<T extends AddressDeleteManyArgs>(
      args?: SelectSubset<T, AddressDeleteManyArgs>
    ): PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    updateMany<T extends AddressUpdateManyArgs>(
      args: SelectSubset<T, AddressUpdateManyArgs>
    ): PrismaPromise<BatchPayload>;

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
     **/
    upsert<T extends AddressUpsertArgs>(
      args: SelectSubset<T, AddressUpsertArgs>
    ): CheckSelect<
      T,
      Prisma__AddressClient<Address>,
      Prisma__AddressClient<AddressGetPayload<T>>
    >;

    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
     **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AddressAggregateArgs>(
      args: Subset<T, AddressAggregateArgs>
    ): PrismaPromise<GetAddressAggregateType<T>>;

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  'Field ',
                  P,
                  ` in "having" needs to be provided in "by"`
                ];
          }[HavingFields]
        : 'take' extends Keys<T>
        ? 'orderBy' extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : 'skip' extends Keys<T>
        ? 'orderBy' extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "skip", you also need to provide "orderBy"'
        : ByValid extends True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
          }[OrderFields]
    >(
      args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAddressGroupByPayload<T>
      : Promise<InputErrors>;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AddressClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(
      _dmmf: runtime.DMMFClass,
      _fetcher: PrismaClientFetcher,
      _queryType: 'query' | 'mutation',
      _rootField: string,
      _clientMethod: string,
      _args: any,
      _dataPath: string[],
      _errorFormat: ErrorFormat,
      _measurePerformance?: boolean | undefined,
      _isList?: boolean
    );
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserFindManyArgs = {}>(
      args?: Subset<T, UserFindManyArgs>
    ): CheckSelect<
      T,
      PrismaPromise<Array<User>>,
      PrismaPromise<Array<UserGetPayload<T>>>
    >;

    Restaurant<T extends RestaurantFindManyArgs = {}>(
      args?: Subset<T, RestaurantFindManyArgs>
    ): CheckSelect<
      T,
      PrismaPromise<Array<Restaurant>>,
      PrismaPromise<Array<RestaurantGetPayload<T>>>
    >;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Address
     *
     **/
    select?: AddressSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: AddressInclude | null;
    /**
     * Throw an Error if a Address can't be found
     *
     **/
    rejectOnNotFound?: RejectOnNotFound;
    /**
     * Filter, which Address to fetch.
     *
     **/
    where: AddressWhereUniqueInput;
  };

  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Address
     *
     **/
    select?: AddressSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: AddressInclude | null;
    /**
     * Throw an Error if a Address can't be found
     *
     **/
    rejectOnNotFound?: RejectOnNotFound;
    /**
     * Filter, which Address to fetch.
     *
     **/
    where?: AddressWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Addresses to fetch.
     *
     **/
    orderBy?: Enumerable<AddressOrderByWithRelationInput>;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Addresses.
     *
     **/
    cursor?: AddressWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Addresses from the position of the cursor.
     *
     **/
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Addresses.
     *
     **/
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Addresses.
     *
     **/
    distinct?: Enumerable<AddressScalarFieldEnum>;
  };

  /**
   * Address findMany
   */
  export type AddressFindManyArgs = {
    /**
     * Select specific fields to fetch from the Address
     *
     **/
    select?: AddressSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: AddressInclude | null;
    /**
     * Filter, which Addresses to fetch.
     *
     **/
    where?: AddressWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Addresses to fetch.
     *
     **/
    orderBy?: Enumerable<AddressOrderByWithRelationInput>;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Addresses.
     *
     **/
    cursor?: AddressWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Addresses from the position of the cursor.
     *
     **/
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Addresses.
     *
     **/
    skip?: number;
    distinct?: Enumerable<AddressScalarFieldEnum>;
  };

  /**
   * Address create
   */
  export type AddressCreateArgs = {
    /**
     * Select specific fields to fetch from the Address
     *
     **/
    select?: AddressSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: AddressInclude | null;
    /**
     * The data needed to create a Address.
     *
     **/
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>;
  };

  /**
   * Address createMany
   */
  export type AddressCreateManyArgs = {
    /**
     * The data used to create many Addresses.
     *
     **/
    data: Enumerable<AddressCreateManyInput>;
    skipDuplicates?: boolean;
  };

  /**
   * Address update
   */
  export type AddressUpdateArgs = {
    /**
     * Select specific fields to fetch from the Address
     *
     **/
    select?: AddressSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: AddressInclude | null;
    /**
     * The data needed to update a Address.
     *
     **/
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>;
    /**
     * Choose, which Address to update.
     *
     **/
    where: AddressWhereUniqueInput;
  };

  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs = {
    /**
     * The data used to update Addresses.
     *
     **/
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>;
    /**
     * Filter which Addresses to update
     *
     **/
    where?: AddressWhereInput;
  };

  /**
   * Address upsert
   */
  export type AddressUpsertArgs = {
    /**
     * Select specific fields to fetch from the Address
     *
     **/
    select?: AddressSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: AddressInclude | null;
    /**
     * The filter to search for the Address to update in case it exists.
     *
     **/
    where: AddressWhereUniqueInput;
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     *
     **/
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>;
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     *
     **/
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>;
  };

  /**
   * Address delete
   */
  export type AddressDeleteArgs = {
    /**
     * Select specific fields to fetch from the Address
     *
     **/
    select?: AddressSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: AddressInclude | null;
    /**
     * Filter which Address to delete.
     *
     **/
    where: AddressWhereUniqueInput;
  };

  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs = {
    /**
     * Filter which Addresses to delete
     *
     **/
    where?: AddressWhereInput;
  };

  /**
   * Address without action
   */
  export type AddressArgs = {
    /**
     * Select specific fields to fetch from the Address
     *
     **/
    select?: AddressSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: AddressInclude | null;
  };

  /**
   * Model Restaurant
   */

  export type AggregateRestaurant = {
    _count: RestaurantCountAggregateOutputType | null;
    _min: RestaurantMinAggregateOutputType | null;
    _max: RestaurantMaxAggregateOutputType | null;
  };

  export type RestaurantMinAggregateOutputType = {
    restauId: string | null;
    restauName: string | null;
    restauDescription: string | null;
    phoneNumber: string | null;
    email: string | null;
    restauAddressId: string | null;
    mainImageId: string | null;
    isActive: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type RestaurantMaxAggregateOutputType = {
    restauId: string | null;
    restauName: string | null;
    restauDescription: string | null;
    phoneNumber: string | null;
    email: string | null;
    restauAddressId: string | null;
    mainImageId: string | null;
    isActive: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type RestaurantCountAggregateOutputType = {
    restauId: number;
    restauName: number;
    restauDescription: number;
    phoneNumber: number;
    email: number;
    restauAddressId: number;
    mainImageId: number;
    isActive: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type RestaurantMinAggregateInputType = {
    restauId?: true;
    restauName?: true;
    restauDescription?: true;
    phoneNumber?: true;
    email?: true;
    restauAddressId?: true;
    mainImageId?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type RestaurantMaxAggregateInputType = {
    restauId?: true;
    restauName?: true;
    restauDescription?: true;
    phoneNumber?: true;
    email?: true;
    restauAddressId?: true;
    mainImageId?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type RestaurantCountAggregateInputType = {
    restauId?: true;
    restauName?: true;
    restauDescription?: true;
    phoneNumber?: true;
    email?: true;
    restauAddressId?: true;
    mainImageId?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type RestaurantAggregateArgs = {
    /**
     * Filter which Restaurant to aggregate.
     *
     **/
    where?: RestaurantWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Restaurants to fetch.
     *
     **/
    orderBy?: Enumerable<RestaurantOrderByWithRelationInput>;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     *
     **/
    cursor?: RestaurantWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Restaurants from the position of the cursor.
     *
     **/
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Restaurants.
     *
     **/
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Restaurants
     **/
    _count?: true | RestaurantCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: RestaurantMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: RestaurantMaxAggregateInputType;
  };

  export type GetRestaurantAggregateType<T extends RestaurantAggregateArgs> = {
    [P in keyof T & keyof AggregateRestaurant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRestaurant[P]>
      : GetScalarType<T[P], AggregateRestaurant[P]>;
  };

  export type RestaurantGroupByArgs = {
    where?: RestaurantWhereInput;
    orderBy?: Enumerable<RestaurantOrderByWithAggregationInput>;
    by: Array<RestaurantScalarFieldEnum>;
    having?: RestaurantScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: RestaurantCountAggregateInputType | true;
    _min?: RestaurantMinAggregateInputType;
    _max?: RestaurantMaxAggregateInputType;
  };

  export type RestaurantGroupByOutputType = {
    restauId: string;
    restauName: string;
    restauDescription: string;
    phoneNumber: string | null;
    email: string | null;
    restauAddressId: string | null;
    mainImageId: string | null;
    isActive: boolean;
    createdAt: Date | null;
    updatedAt: Date | null;
    _count: RestaurantCountAggregateOutputType | null;
    _min: RestaurantMinAggregateOutputType | null;
    _max: RestaurantMaxAggregateOutputType | null;
  };

  type GetRestaurantGroupByPayload<T extends RestaurantGroupByArgs> = Promise<
    Array<
      PickArray<RestaurantGroupByOutputType, T['by']> & {
        [P in keyof T & keyof RestaurantGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], RestaurantGroupByOutputType[P]>
          : GetScalarType<T[P], RestaurantGroupByOutputType[P]>;
      }
    >
  >;

  export type RestaurantSelect = {
    restauId?: boolean;
    restauName?: boolean;
    restauDescription?: boolean;
    phoneNumber?: boolean;
    email?: boolean;
    RestauAddress?: boolean | AddressArgs;
    RestauImages?: boolean | RestauImagesArgs;
    RestaurantUser?: boolean | RestauUserFindManyArgs;
    restauAddressId?: boolean;
    mainImageId?: boolean;
    isActive?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    _count?: boolean | RestaurantCountOutputTypeArgs;
  };

  export type RestaurantInclude = {
    RestauAddress?: boolean | AddressArgs;
    RestauImages?: boolean | RestauImagesArgs;
    RestaurantUser?: boolean | RestauUserFindManyArgs;
    _count?: boolean | RestaurantCountOutputTypeArgs;
  };

  export type RestaurantGetPayload<
    S extends boolean | null | undefined | RestaurantArgs,
    U = keyof S
  > = S extends true
    ? Restaurant
    : S extends undefined
    ? never
    : S extends RestaurantArgs | RestaurantFindManyArgs
    ? 'include' extends U
      ? Restaurant & {
          [P in TrueKeys<S['include']>]: P extends 'RestauAddress'
            ? AddressGetPayload<S['include'][P]> | null
            : P extends 'RestauImages'
            ? RestauImagesGetPayload<S['include'][P]> | null
            : P extends 'RestaurantUser'
            ? Array<RestauUserGetPayload<S['include'][P]>>
            : P extends '_count'
            ? RestaurantCountOutputTypeGetPayload<S['include'][P]>
            : never;
        }
      : 'select' extends U
      ? {
          [P in TrueKeys<S['select']>]: P extends keyof Restaurant
            ? Restaurant[P]
            : P extends 'RestauAddress'
            ? AddressGetPayload<S['select'][P]> | null
            : P extends 'RestauImages'
            ? RestauImagesGetPayload<S['select'][P]> | null
            : P extends 'RestaurantUser'
            ? Array<RestauUserGetPayload<S['select'][P]>>
            : P extends '_count'
            ? RestaurantCountOutputTypeGetPayload<S['select'][P]>
            : never;
        }
      : Restaurant
    : Restaurant;

  type RestaurantCountArgs = Merge<
    Omit<RestaurantFindManyArgs, 'select' | 'include'> & {
      select?: RestaurantCountAggregateInputType | true;
    }
  >;

  export interface RestaurantDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Restaurant that matches the filter.
     * @param {RestaurantFindUniqueArgs} args - Arguments to find a Restaurant
     * @example
     * // Get one Restaurant
     * const restaurant = await prisma.restaurant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUnique<
      T extends RestaurantFindUniqueArgs,
      LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound
        ? T['rejectOnNotFound']
        : undefined
    >(
      args: SelectSubset<T, RestaurantFindUniqueArgs>
    ): HasReject<
      GlobalRejectSettings,
      LocalRejectSettings,
      'findUnique',
      'Restaurant'
    > extends True
      ? CheckSelect<
          T,
          Prisma__RestaurantClient<Restaurant>,
          Prisma__RestaurantClient<RestaurantGetPayload<T>>
        >
      : CheckSelect<
          T,
          Prisma__RestaurantClient<Restaurant | null>,
          Prisma__RestaurantClient<RestaurantGetPayload<T> | null>
        >;

    /**
     * Find the first Restaurant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantFindFirstArgs} args - Arguments to find a Restaurant
     * @example
     * // Get one Restaurant
     * const restaurant = await prisma.restaurant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirst<
      T extends RestaurantFindFirstArgs,
      LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound
        ? T['rejectOnNotFound']
        : undefined
    >(
      args?: SelectSubset<T, RestaurantFindFirstArgs>
    ): HasReject<
      GlobalRejectSettings,
      LocalRejectSettings,
      'findFirst',
      'Restaurant'
    > extends True
      ? CheckSelect<
          T,
          Prisma__RestaurantClient<Restaurant>,
          Prisma__RestaurantClient<RestaurantGetPayload<T>>
        >
      : CheckSelect<
          T,
          Prisma__RestaurantClient<Restaurant | null>,
          Prisma__RestaurantClient<RestaurantGetPayload<T> | null>
        >;

    /**
     * Find zero or more Restaurants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Restaurants
     * const restaurants = await prisma.restaurant.findMany()
     *
     * // Get first 10 Restaurants
     * const restaurants = await prisma.restaurant.findMany({ take: 10 })
     *
     * // Only select the `restauId`
     * const restaurantWithRestauIdOnly = await prisma.restaurant.findMany({ select: { restauId: true } })
     *
     **/
    findMany<T extends RestaurantFindManyArgs>(
      args?: SelectSubset<T, RestaurantFindManyArgs>
    ): CheckSelect<
      T,
      PrismaPromise<Array<Restaurant>>,
      PrismaPromise<Array<RestaurantGetPayload<T>>>
    >;

    /**
     * Create a Restaurant.
     * @param {RestaurantCreateArgs} args - Arguments to create a Restaurant.
     * @example
     * // Create one Restaurant
     * const Restaurant = await prisma.restaurant.create({
     *   data: {
     *     // ... data to create a Restaurant
     *   }
     * })
     *
     **/
    create<T extends RestaurantCreateArgs>(
      args: SelectSubset<T, RestaurantCreateArgs>
    ): CheckSelect<
      T,
      Prisma__RestaurantClient<Restaurant>,
      Prisma__RestaurantClient<RestaurantGetPayload<T>>
    >;

    /**
     * Create many Restaurants.
     *     @param {RestaurantCreateManyArgs} args - Arguments to create many Restaurants.
     *     @example
     *     // Create many Restaurants
     *     const restaurant = await prisma.restaurant.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
     **/
    createMany<T extends RestaurantCreateManyArgs>(
      args?: SelectSubset<T, RestaurantCreateManyArgs>
    ): PrismaPromise<BatchPayload>;

    /**
     * Delete a Restaurant.
     * @param {RestaurantDeleteArgs} args - Arguments to delete one Restaurant.
     * @example
     * // Delete one Restaurant
     * const Restaurant = await prisma.restaurant.delete({
     *   where: {
     *     // ... filter to delete one Restaurant
     *   }
     * })
     *
     **/
    delete<T extends RestaurantDeleteArgs>(
      args: SelectSubset<T, RestaurantDeleteArgs>
    ): CheckSelect<
      T,
      Prisma__RestaurantClient<Restaurant>,
      Prisma__RestaurantClient<RestaurantGetPayload<T>>
    >;

    /**
     * Update one Restaurant.
     * @param {RestaurantUpdateArgs} args - Arguments to update one Restaurant.
     * @example
     * // Update one Restaurant
     * const restaurant = await prisma.restaurant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    update<T extends RestaurantUpdateArgs>(
      args: SelectSubset<T, RestaurantUpdateArgs>
    ): CheckSelect<
      T,
      Prisma__RestaurantClient<Restaurant>,
      Prisma__RestaurantClient<RestaurantGetPayload<T>>
    >;

    /**
     * Delete zero or more Restaurants.
     * @param {RestaurantDeleteManyArgs} args - Arguments to filter Restaurants to delete.
     * @example
     * // Delete a few Restaurants
     * const { count } = await prisma.restaurant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     **/
    deleteMany<T extends RestaurantDeleteManyArgs>(
      args?: SelectSubset<T, RestaurantDeleteManyArgs>
    ): PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Restaurants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Restaurants
     * const restaurant = await prisma.restaurant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    updateMany<T extends RestaurantUpdateManyArgs>(
      args: SelectSubset<T, RestaurantUpdateManyArgs>
    ): PrismaPromise<BatchPayload>;

    /**
     * Create or update one Restaurant.
     * @param {RestaurantUpsertArgs} args - Arguments to update or create a Restaurant.
     * @example
     * // Update or create a Restaurant
     * const restaurant = await prisma.restaurant.upsert({
     *   create: {
     *     // ... data to create a Restaurant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Restaurant we want to update
     *   }
     * })
     **/
    upsert<T extends RestaurantUpsertArgs>(
      args: SelectSubset<T, RestaurantUpsertArgs>
    ): CheckSelect<
      T,
      Prisma__RestaurantClient<Restaurant>,
      Prisma__RestaurantClient<RestaurantGetPayload<T>>
    >;

    /**
     * Count the number of Restaurants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantCountArgs} args - Arguments to filter Restaurants to count.
     * @example
     * // Count the number of Restaurants
     * const count = await prisma.restaurant.count({
     *   where: {
     *     // ... the filter for the Restaurants we want to count
     *   }
     * })
     **/
    count<T extends RestaurantCountArgs>(
      args?: Subset<T, RestaurantCountArgs>
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RestaurantCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Restaurant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends RestaurantAggregateArgs>(
      args: Subset<T, RestaurantAggregateArgs>
    ): PrismaPromise<GetRestaurantAggregateType<T>>;

    /**
     * Group by Restaurant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends RestaurantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RestaurantGroupByArgs['orderBy'] }
        : { orderBy?: RestaurantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  'Field ',
                  P,
                  ` in "having" needs to be provided in "by"`
                ];
          }[HavingFields]
        : 'take' extends Keys<T>
        ? 'orderBy' extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : 'skip' extends Keys<T>
        ? 'orderBy' extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "skip", you also need to provide "orderBy"'
        : ByValid extends True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
          }[OrderFields]
    >(
      args: SubsetIntersection<T, RestaurantGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetRestaurantGroupByPayload<T>
      : Promise<InputErrors>;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Restaurant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RestaurantClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(
      _dmmf: runtime.DMMFClass,
      _fetcher: PrismaClientFetcher,
      _queryType: 'query' | 'mutation',
      _rootField: string,
      _clientMethod: string,
      _args: any,
      _dataPath: string[],
      _errorFormat: ErrorFormat,
      _measurePerformance?: boolean | undefined,
      _isList?: boolean
    );
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    RestauAddress<T extends AddressArgs = {}>(
      args?: Subset<T, AddressArgs>
    ): CheckSelect<
      T,
      Prisma__AddressClient<Address | null>,
      Prisma__AddressClient<AddressGetPayload<T> | null>
    >;

    RestauImages<T extends RestauImagesArgs = {}>(
      args?: Subset<T, RestauImagesArgs>
    ): CheckSelect<
      T,
      Prisma__RestauImagesClient<RestauImages | null>,
      Prisma__RestauImagesClient<RestauImagesGetPayload<T> | null>
    >;

    RestaurantUser<T extends RestauUserFindManyArgs = {}>(
      args?: Subset<T, RestauUserFindManyArgs>
    ): CheckSelect<
      T,
      PrismaPromise<Array<RestauUser>>,
      PrismaPromise<Array<RestauUserGetPayload<T>>>
    >;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Restaurant findUnique
   */
  export type RestaurantFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Restaurant
     *
     **/
    select?: RestaurantSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RestaurantInclude | null;
    /**
     * Throw an Error if a Restaurant can't be found
     *
     **/
    rejectOnNotFound?: RejectOnNotFound;
    /**
     * Filter, which Restaurant to fetch.
     *
     **/
    where: RestaurantWhereUniqueInput;
  };

  /**
   * Restaurant findFirst
   */
  export type RestaurantFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Restaurant
     *
     **/
    select?: RestaurantSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RestaurantInclude | null;
    /**
     * Throw an Error if a Restaurant can't be found
     *
     **/
    rejectOnNotFound?: RejectOnNotFound;
    /**
     * Filter, which Restaurant to fetch.
     *
     **/
    where?: RestaurantWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Restaurants to fetch.
     *
     **/
    orderBy?: Enumerable<RestaurantOrderByWithRelationInput>;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Restaurants.
     *
     **/
    cursor?: RestaurantWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Restaurants from the position of the cursor.
     *
     **/
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Restaurants.
     *
     **/
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Restaurants.
     *
     **/
    distinct?: Enumerable<RestaurantScalarFieldEnum>;
  };

  /**
   * Restaurant findMany
   */
  export type RestaurantFindManyArgs = {
    /**
     * Select specific fields to fetch from the Restaurant
     *
     **/
    select?: RestaurantSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RestaurantInclude | null;
    /**
     * Filter, which Restaurants to fetch.
     *
     **/
    where?: RestaurantWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Restaurants to fetch.
     *
     **/
    orderBy?: Enumerable<RestaurantOrderByWithRelationInput>;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Restaurants.
     *
     **/
    cursor?: RestaurantWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Restaurants from the position of the cursor.
     *
     **/
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Restaurants.
     *
     **/
    skip?: number;
    distinct?: Enumerable<RestaurantScalarFieldEnum>;
  };

  /**
   * Restaurant create
   */
  export type RestaurantCreateArgs = {
    /**
     * Select specific fields to fetch from the Restaurant
     *
     **/
    select?: RestaurantSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RestaurantInclude | null;
    /**
     * The data needed to create a Restaurant.
     *
     **/
    data: XOR<RestaurantCreateInput, RestaurantUncheckedCreateInput>;
  };

  /**
   * Restaurant createMany
   */
  export type RestaurantCreateManyArgs = {
    /**
     * The data used to create many Restaurants.
     *
     **/
    data: Enumerable<RestaurantCreateManyInput>;
    skipDuplicates?: boolean;
  };

  /**
   * Restaurant update
   */
  export type RestaurantUpdateArgs = {
    /**
     * Select specific fields to fetch from the Restaurant
     *
     **/
    select?: RestaurantSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RestaurantInclude | null;
    /**
     * The data needed to update a Restaurant.
     *
     **/
    data: XOR<RestaurantUpdateInput, RestaurantUncheckedUpdateInput>;
    /**
     * Choose, which Restaurant to update.
     *
     **/
    where: RestaurantWhereUniqueInput;
  };

  /**
   * Restaurant updateMany
   */
  export type RestaurantUpdateManyArgs = {
    /**
     * The data used to update Restaurants.
     *
     **/
    data: XOR<
      RestaurantUpdateManyMutationInput,
      RestaurantUncheckedUpdateManyInput
    >;
    /**
     * Filter which Restaurants to update
     *
     **/
    where?: RestaurantWhereInput;
  };

  /**
   * Restaurant upsert
   */
  export type RestaurantUpsertArgs = {
    /**
     * Select specific fields to fetch from the Restaurant
     *
     **/
    select?: RestaurantSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RestaurantInclude | null;
    /**
     * The filter to search for the Restaurant to update in case it exists.
     *
     **/
    where: RestaurantWhereUniqueInput;
    /**
     * In case the Restaurant found by the `where` argument doesn't exist, create a new Restaurant with this data.
     *
     **/
    create: XOR<RestaurantCreateInput, RestaurantUncheckedCreateInput>;
    /**
     * In case the Restaurant was found with the provided `where` argument, update it with this data.
     *
     **/
    update: XOR<RestaurantUpdateInput, RestaurantUncheckedUpdateInput>;
  };

  /**
   * Restaurant delete
   */
  export type RestaurantDeleteArgs = {
    /**
     * Select specific fields to fetch from the Restaurant
     *
     **/
    select?: RestaurantSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RestaurantInclude | null;
    /**
     * Filter which Restaurant to delete.
     *
     **/
    where: RestaurantWhereUniqueInput;
  };

  /**
   * Restaurant deleteMany
   */
  export type RestaurantDeleteManyArgs = {
    /**
     * Filter which Restaurants to delete
     *
     **/
    where?: RestaurantWhereInput;
  };

  /**
   * Restaurant without action
   */
  export type RestaurantArgs = {
    /**
     * Select specific fields to fetch from the Restaurant
     *
     **/
    select?: RestaurantSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RestaurantInclude | null;
  };

  /**
   * Model RestauTokens
   */

  export type AggregateRestauTokens = {
    _count: RestauTokensCountAggregateOutputType | null;
    _min: RestauTokensMinAggregateOutputType | null;
    _max: RestauTokensMaxAggregateOutputType | null;
  };

  export type RestauTokensMinAggregateOutputType = {
    tokenId: string | null;
    token: string | null;
    restauUserId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type RestauTokensMaxAggregateOutputType = {
    tokenId: string | null;
    token: string | null;
    restauUserId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type RestauTokensCountAggregateOutputType = {
    tokenId: number;
    token: number;
    restauUserId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type RestauTokensMinAggregateInputType = {
    tokenId?: true;
    token?: true;
    restauUserId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type RestauTokensMaxAggregateInputType = {
    tokenId?: true;
    token?: true;
    restauUserId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type RestauTokensCountAggregateInputType = {
    tokenId?: true;
    token?: true;
    restauUserId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type RestauTokensAggregateArgs = {
    /**
     * Filter which RestauTokens to aggregate.
     *
     **/
    where?: RestauTokensWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RestauTokens to fetch.
     *
     **/
    orderBy?: Enumerable<RestauTokensOrderByWithRelationInput>;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     *
     **/
    cursor?: RestauTokensWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RestauTokens from the position of the cursor.
     *
     **/
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RestauTokens.
     *
     **/
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned RestauTokens
     **/
    _count?: true | RestauTokensCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: RestauTokensMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: RestauTokensMaxAggregateInputType;
  };

  export type GetRestauTokensAggregateType<
    T extends RestauTokensAggregateArgs
  > = {
    [P in keyof T & keyof AggregateRestauTokens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRestauTokens[P]>
      : GetScalarType<T[P], AggregateRestauTokens[P]>;
  };

  export type RestauTokensGroupByArgs = {
    where?: RestauTokensWhereInput;
    orderBy?: Enumerable<RestauTokensOrderByWithAggregationInput>;
    by: Array<RestauTokensScalarFieldEnum>;
    having?: RestauTokensScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: RestauTokensCountAggregateInputType | true;
    _min?: RestauTokensMinAggregateInputType;
    _max?: RestauTokensMaxAggregateInputType;
  };

  export type RestauTokensGroupByOutputType = {
    tokenId: string;
    token: string;
    restauUserId: string;
    createdAt: Date | null;
    updatedAt: Date | null;
    _count: RestauTokensCountAggregateOutputType | null;
    _min: RestauTokensMinAggregateOutputType | null;
    _max: RestauTokensMaxAggregateOutputType | null;
  };

  type GetRestauTokensGroupByPayload<T extends RestauTokensGroupByArgs> =
    Promise<
      Array<
        PickArray<RestauTokensGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof RestauTokensGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RestauTokensGroupByOutputType[P]>
            : GetScalarType<T[P], RestauTokensGroupByOutputType[P]>;
        }
      >
    >;

  export type RestauTokensSelect = {
    tokenId?: boolean;
    token?: boolean;
    RestauUser?: boolean | RestauUserArgs;
    restauUserId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type RestauTokensInclude = {
    RestauUser?: boolean | RestauUserArgs;
  };

  export type RestauTokensGetPayload<
    S extends boolean | null | undefined | RestauTokensArgs,
    U = keyof S
  > = S extends true
    ? RestauTokens
    : S extends undefined
    ? never
    : S extends RestauTokensArgs | RestauTokensFindManyArgs
    ? 'include' extends U
      ? RestauTokens & {
          [P in TrueKeys<S['include']>]: P extends 'RestauUser'
            ? RestauUserGetPayload<S['include'][P]> | null
            : never;
        }
      : 'select' extends U
      ? {
          [P in TrueKeys<S['select']>]: P extends keyof RestauTokens
            ? RestauTokens[P]
            : P extends 'RestauUser'
            ? RestauUserGetPayload<S['select'][P]> | null
            : never;
        }
      : RestauTokens
    : RestauTokens;

  type RestauTokensCountArgs = Merge<
    Omit<RestauTokensFindManyArgs, 'select' | 'include'> & {
      select?: RestauTokensCountAggregateInputType | true;
    }
  >;

  export interface RestauTokensDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one RestauTokens that matches the filter.
     * @param {RestauTokensFindUniqueArgs} args - Arguments to find a RestauTokens
     * @example
     * // Get one RestauTokens
     * const restauTokens = await prisma.restauTokens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUnique<
      T extends RestauTokensFindUniqueArgs,
      LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound
        ? T['rejectOnNotFound']
        : undefined
    >(
      args: SelectSubset<T, RestauTokensFindUniqueArgs>
    ): HasReject<
      GlobalRejectSettings,
      LocalRejectSettings,
      'findUnique',
      'RestauTokens'
    > extends True
      ? CheckSelect<
          T,
          Prisma__RestauTokensClient<RestauTokens>,
          Prisma__RestauTokensClient<RestauTokensGetPayload<T>>
        >
      : CheckSelect<
          T,
          Prisma__RestauTokensClient<RestauTokens | null>,
          Prisma__RestauTokensClient<RestauTokensGetPayload<T> | null>
        >;

    /**
     * Find the first RestauTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestauTokensFindFirstArgs} args - Arguments to find a RestauTokens
     * @example
     * // Get one RestauTokens
     * const restauTokens = await prisma.restauTokens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirst<
      T extends RestauTokensFindFirstArgs,
      LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound
        ? T['rejectOnNotFound']
        : undefined
    >(
      args?: SelectSubset<T, RestauTokensFindFirstArgs>
    ): HasReject<
      GlobalRejectSettings,
      LocalRejectSettings,
      'findFirst',
      'RestauTokens'
    > extends True
      ? CheckSelect<
          T,
          Prisma__RestauTokensClient<RestauTokens>,
          Prisma__RestauTokensClient<RestauTokensGetPayload<T>>
        >
      : CheckSelect<
          T,
          Prisma__RestauTokensClient<RestauTokens | null>,
          Prisma__RestauTokensClient<RestauTokensGetPayload<T> | null>
        >;

    /**
     * Find zero or more RestauTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestauTokensFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RestauTokens
     * const restauTokens = await prisma.restauTokens.findMany()
     *
     * // Get first 10 RestauTokens
     * const restauTokens = await prisma.restauTokens.findMany({ take: 10 })
     *
     * // Only select the `tokenId`
     * const restauTokensWithTokenIdOnly = await prisma.restauTokens.findMany({ select: { tokenId: true } })
     *
     **/
    findMany<T extends RestauTokensFindManyArgs>(
      args?: SelectSubset<T, RestauTokensFindManyArgs>
    ): CheckSelect<
      T,
      PrismaPromise<Array<RestauTokens>>,
      PrismaPromise<Array<RestauTokensGetPayload<T>>>
    >;

    /**
     * Create a RestauTokens.
     * @param {RestauTokensCreateArgs} args - Arguments to create a RestauTokens.
     * @example
     * // Create one RestauTokens
     * const RestauTokens = await prisma.restauTokens.create({
     *   data: {
     *     // ... data to create a RestauTokens
     *   }
     * })
     *
     **/
    create<T extends RestauTokensCreateArgs>(
      args: SelectSubset<T, RestauTokensCreateArgs>
    ): CheckSelect<
      T,
      Prisma__RestauTokensClient<RestauTokens>,
      Prisma__RestauTokensClient<RestauTokensGetPayload<T>>
    >;

    /**
     * Create many RestauTokens.
     *     @param {RestauTokensCreateManyArgs} args - Arguments to create many RestauTokens.
     *     @example
     *     // Create many RestauTokens
     *     const restauTokens = await prisma.restauTokens.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
     **/
    createMany<T extends RestauTokensCreateManyArgs>(
      args?: SelectSubset<T, RestauTokensCreateManyArgs>
    ): PrismaPromise<BatchPayload>;

    /**
     * Delete a RestauTokens.
     * @param {RestauTokensDeleteArgs} args - Arguments to delete one RestauTokens.
     * @example
     * // Delete one RestauTokens
     * const RestauTokens = await prisma.restauTokens.delete({
     *   where: {
     *     // ... filter to delete one RestauTokens
     *   }
     * })
     *
     **/
    delete<T extends RestauTokensDeleteArgs>(
      args: SelectSubset<T, RestauTokensDeleteArgs>
    ): CheckSelect<
      T,
      Prisma__RestauTokensClient<RestauTokens>,
      Prisma__RestauTokensClient<RestauTokensGetPayload<T>>
    >;

    /**
     * Update one RestauTokens.
     * @param {RestauTokensUpdateArgs} args - Arguments to update one RestauTokens.
     * @example
     * // Update one RestauTokens
     * const restauTokens = await prisma.restauTokens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    update<T extends RestauTokensUpdateArgs>(
      args: SelectSubset<T, RestauTokensUpdateArgs>
    ): CheckSelect<
      T,
      Prisma__RestauTokensClient<RestauTokens>,
      Prisma__RestauTokensClient<RestauTokensGetPayload<T>>
    >;

    /**
     * Delete zero or more RestauTokens.
     * @param {RestauTokensDeleteManyArgs} args - Arguments to filter RestauTokens to delete.
     * @example
     * // Delete a few RestauTokens
     * const { count } = await prisma.restauTokens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     **/
    deleteMany<T extends RestauTokensDeleteManyArgs>(
      args?: SelectSubset<T, RestauTokensDeleteManyArgs>
    ): PrismaPromise<BatchPayload>;

    /**
     * Update zero or more RestauTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestauTokensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RestauTokens
     * const restauTokens = await prisma.restauTokens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    updateMany<T extends RestauTokensUpdateManyArgs>(
      args: SelectSubset<T, RestauTokensUpdateManyArgs>
    ): PrismaPromise<BatchPayload>;

    /**
     * Create or update one RestauTokens.
     * @param {RestauTokensUpsertArgs} args - Arguments to update or create a RestauTokens.
     * @example
     * // Update or create a RestauTokens
     * const restauTokens = await prisma.restauTokens.upsert({
     *   create: {
     *     // ... data to create a RestauTokens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RestauTokens we want to update
     *   }
     * })
     **/
    upsert<T extends RestauTokensUpsertArgs>(
      args: SelectSubset<T, RestauTokensUpsertArgs>
    ): CheckSelect<
      T,
      Prisma__RestauTokensClient<RestauTokens>,
      Prisma__RestauTokensClient<RestauTokensGetPayload<T>>
    >;

    /**
     * Count the number of RestauTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestauTokensCountArgs} args - Arguments to filter RestauTokens to count.
     * @example
     * // Count the number of RestauTokens
     * const count = await prisma.restauTokens.count({
     *   where: {
     *     // ... the filter for the RestauTokens we want to count
     *   }
     * })
     **/
    count<T extends RestauTokensCountArgs>(
      args?: Subset<T, RestauTokensCountArgs>
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RestauTokensCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a RestauTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestauTokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends RestauTokensAggregateArgs>(
      args: Subset<T, RestauTokensAggregateArgs>
    ): PrismaPromise<GetRestauTokensAggregateType<T>>;

    /**
     * Group by RestauTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestauTokensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends RestauTokensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RestauTokensGroupByArgs['orderBy'] }
        : { orderBy?: RestauTokensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  'Field ',
                  P,
                  ` in "having" needs to be provided in "by"`
                ];
          }[HavingFields]
        : 'take' extends Keys<T>
        ? 'orderBy' extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : 'skip' extends Keys<T>
        ? 'orderBy' extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "skip", you also need to provide "orderBy"'
        : ByValid extends True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
          }[OrderFields]
    >(
      args: SubsetIntersection<T, RestauTokensGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetRestauTokensGroupByPayload<T>
      : Promise<InputErrors>;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RestauTokens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RestauTokensClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(
      _dmmf: runtime.DMMFClass,
      _fetcher: PrismaClientFetcher,
      _queryType: 'query' | 'mutation',
      _rootField: string,
      _clientMethod: string,
      _args: any,
      _dataPath: string[],
      _errorFormat: ErrorFormat,
      _measurePerformance?: boolean | undefined,
      _isList?: boolean
    );
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    RestauUser<T extends RestauUserArgs = {}>(
      args?: Subset<T, RestauUserArgs>
    ): CheckSelect<
      T,
      Prisma__RestauUserClient<RestauUser | null>,
      Prisma__RestauUserClient<RestauUserGetPayload<T> | null>
    >;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * RestauTokens findUnique
   */
  export type RestauTokensFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the RestauTokens
     *
     **/
    select?: RestauTokensSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RestauTokensInclude | null;
    /**
     * Throw an Error if a RestauTokens can't be found
     *
     **/
    rejectOnNotFound?: RejectOnNotFound;
    /**
     * Filter, which RestauTokens to fetch.
     *
     **/
    where: RestauTokensWhereUniqueInput;
  };

  /**
   * RestauTokens findFirst
   */
  export type RestauTokensFindFirstArgs = {
    /**
     * Select specific fields to fetch from the RestauTokens
     *
     **/
    select?: RestauTokensSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RestauTokensInclude | null;
    /**
     * Throw an Error if a RestauTokens can't be found
     *
     **/
    rejectOnNotFound?: RejectOnNotFound;
    /**
     * Filter, which RestauTokens to fetch.
     *
     **/
    where?: RestauTokensWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RestauTokens to fetch.
     *
     **/
    orderBy?: Enumerable<RestauTokensOrderByWithRelationInput>;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for RestauTokens.
     *
     **/
    cursor?: RestauTokensWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RestauTokens from the position of the cursor.
     *
     **/
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RestauTokens.
     *
     **/
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of RestauTokens.
     *
     **/
    distinct?: Enumerable<RestauTokensScalarFieldEnum>;
  };

  /**
   * RestauTokens findMany
   */
  export type RestauTokensFindManyArgs = {
    /**
     * Select specific fields to fetch from the RestauTokens
     *
     **/
    select?: RestauTokensSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RestauTokensInclude | null;
    /**
     * Filter, which RestauTokens to fetch.
     *
     **/
    where?: RestauTokensWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RestauTokens to fetch.
     *
     **/
    orderBy?: Enumerable<RestauTokensOrderByWithRelationInput>;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing RestauTokens.
     *
     **/
    cursor?: RestauTokensWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RestauTokens from the position of the cursor.
     *
     **/
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RestauTokens.
     *
     **/
    skip?: number;
    distinct?: Enumerable<RestauTokensScalarFieldEnum>;
  };

  /**
   * RestauTokens create
   */
  export type RestauTokensCreateArgs = {
    /**
     * Select specific fields to fetch from the RestauTokens
     *
     **/
    select?: RestauTokensSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RestauTokensInclude | null;
    /**
     * The data needed to create a RestauTokens.
     *
     **/
    data: XOR<RestauTokensCreateInput, RestauTokensUncheckedCreateInput>;
  };

  /**
   * RestauTokens createMany
   */
  export type RestauTokensCreateManyArgs = {
    /**
     * The data used to create many RestauTokens.
     *
     **/
    data: Enumerable<RestauTokensCreateManyInput>;
    skipDuplicates?: boolean;
  };

  /**
   * RestauTokens update
   */
  export type RestauTokensUpdateArgs = {
    /**
     * Select specific fields to fetch from the RestauTokens
     *
     **/
    select?: RestauTokensSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RestauTokensInclude | null;
    /**
     * The data needed to update a RestauTokens.
     *
     **/
    data: XOR<RestauTokensUpdateInput, RestauTokensUncheckedUpdateInput>;
    /**
     * Choose, which RestauTokens to update.
     *
     **/
    where: RestauTokensWhereUniqueInput;
  };

  /**
   * RestauTokens updateMany
   */
  export type RestauTokensUpdateManyArgs = {
    /**
     * The data used to update RestauTokens.
     *
     **/
    data: XOR<
      RestauTokensUpdateManyMutationInput,
      RestauTokensUncheckedUpdateManyInput
    >;
    /**
     * Filter which RestauTokens to update
     *
     **/
    where?: RestauTokensWhereInput;
  };

  /**
   * RestauTokens upsert
   */
  export type RestauTokensUpsertArgs = {
    /**
     * Select specific fields to fetch from the RestauTokens
     *
     **/
    select?: RestauTokensSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RestauTokensInclude | null;
    /**
     * The filter to search for the RestauTokens to update in case it exists.
     *
     **/
    where: RestauTokensWhereUniqueInput;
    /**
     * In case the RestauTokens found by the `where` argument doesn't exist, create a new RestauTokens with this data.
     *
     **/
    create: XOR<RestauTokensCreateInput, RestauTokensUncheckedCreateInput>;
    /**
     * In case the RestauTokens was found with the provided `where` argument, update it with this data.
     *
     **/
    update: XOR<RestauTokensUpdateInput, RestauTokensUncheckedUpdateInput>;
  };

  /**
   * RestauTokens delete
   */
  export type RestauTokensDeleteArgs = {
    /**
     * Select specific fields to fetch from the RestauTokens
     *
     **/
    select?: RestauTokensSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RestauTokensInclude | null;
    /**
     * Filter which RestauTokens to delete.
     *
     **/
    where: RestauTokensWhereUniqueInput;
  };

  /**
   * RestauTokens deleteMany
   */
  export type RestauTokensDeleteManyArgs = {
    /**
     * Filter which RestauTokens to delete
     *
     **/
    where?: RestauTokensWhereInput;
  };

  /**
   * RestauTokens without action
   */
  export type RestauTokensArgs = {
    /**
     * Select specific fields to fetch from the RestauTokens
     *
     **/
    select?: RestauTokensSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RestauTokensInclude | null;
  };

  /**
   * Model RestauUser
   */

  export type AggregateRestauUser = {
    _count: RestauUserCountAggregateOutputType | null;
    _min: RestauUserMinAggregateOutputType | null;
    _max: RestauUserMaxAggregateOutputType | null;
  };

  export type RestauUserMinAggregateOutputType = {
    restauUserId: string | null;
    restauId: string | null;
    userName: string | null;
    phoneNumber: string | null;
    completeName: string | null;
    userImage: string | null;
    password: string | null;
    role: RestauRole | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type RestauUserMaxAggregateOutputType = {
    restauUserId: string | null;
    restauId: string | null;
    userName: string | null;
    phoneNumber: string | null;
    completeName: string | null;
    userImage: string | null;
    password: string | null;
    role: RestauRole | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type RestauUserCountAggregateOutputType = {
    restauUserId: number;
    restauId: number;
    userName: number;
    phoneNumber: number;
    completeName: number;
    userImage: number;
    password: number;
    role: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type RestauUserMinAggregateInputType = {
    restauUserId?: true;
    restauId?: true;
    userName?: true;
    phoneNumber?: true;
    completeName?: true;
    userImage?: true;
    password?: true;
    role?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type RestauUserMaxAggregateInputType = {
    restauUserId?: true;
    restauId?: true;
    userName?: true;
    phoneNumber?: true;
    completeName?: true;
    userImage?: true;
    password?: true;
    role?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type RestauUserCountAggregateInputType = {
    restauUserId?: true;
    restauId?: true;
    userName?: true;
    phoneNumber?: true;
    completeName?: true;
    userImage?: true;
    password?: true;
    role?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type RestauUserAggregateArgs = {
    /**
     * Filter which RestauUser to aggregate.
     *
     **/
    where?: RestauUserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RestauUsers to fetch.
     *
     **/
    orderBy?: Enumerable<RestauUserOrderByWithRelationInput>;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     *
     **/
    cursor?: RestauUserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RestauUsers from the position of the cursor.
     *
     **/
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RestauUsers.
     *
     **/
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned RestauUsers
     **/
    _count?: true | RestauUserCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: RestauUserMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: RestauUserMaxAggregateInputType;
  };

  export type GetRestauUserAggregateType<T extends RestauUserAggregateArgs> = {
    [P in keyof T & keyof AggregateRestauUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRestauUser[P]>
      : GetScalarType<T[P], AggregateRestauUser[P]>;
  };

  export type RestauUserGroupByArgs = {
    where?: RestauUserWhereInput;
    orderBy?: Enumerable<RestauUserOrderByWithAggregationInput>;
    by: Array<RestauUserScalarFieldEnum>;
    having?: RestauUserScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: RestauUserCountAggregateInputType | true;
    _min?: RestauUserMinAggregateInputType;
    _max?: RestauUserMaxAggregateInputType;
  };

  export type RestauUserGroupByOutputType = {
    restauUserId: string;
    restauId: string;
    userName: string;
    phoneNumber: string;
    completeName: string;
    userImage: string;
    password: string;
    role: RestauRole;
    createdAt: Date | null;
    updatedAt: Date | null;
    _count: RestauUserCountAggregateOutputType | null;
    _min: RestauUserMinAggregateOutputType | null;
    _max: RestauUserMaxAggregateOutputType | null;
  };

  type GetRestauUserGroupByPayload<T extends RestauUserGroupByArgs> = Promise<
    Array<
      PickArray<RestauUserGroupByOutputType, T['by']> & {
        [P in keyof T & keyof RestauUserGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], RestauUserGroupByOutputType[P]>
          : GetScalarType<T[P], RestauUserGroupByOutputType[P]>;
      }
    >
  >;

  export type RestauUserSelect = {
    restauUserId?: boolean;
    Token?: boolean | RestauTokensFindManyArgs;
    restauId?: boolean;
    userName?: boolean;
    phoneNumber?: boolean;
    completeName?: boolean;
    userImage?: boolean;
    password?: boolean;
    role?: boolean;
    RestauImages?: boolean | RestauImagesArgs;
    Restaurant?: boolean | RestaurantArgs;
    createdAt?: boolean;
    updatedAt?: boolean;
    _count?: boolean | RestauUserCountOutputTypeArgs;
  };

  export type RestauUserInclude = {
    Token?: boolean | RestauTokensFindManyArgs;
    RestauImages?: boolean | RestauImagesArgs;
    Restaurant?: boolean | RestaurantArgs;
    _count?: boolean | RestauUserCountOutputTypeArgs;
  };

  export type RestauUserGetPayload<
    S extends boolean | null | undefined | RestauUserArgs,
    U = keyof S
  > = S extends true
    ? RestauUser
    : S extends undefined
    ? never
    : S extends RestauUserArgs | RestauUserFindManyArgs
    ? 'include' extends U
      ? RestauUser & {
          [P in TrueKeys<S['include']>]: P extends 'Token'
            ? Array<RestauTokensGetPayload<S['include'][P]>>
            : P extends 'RestauImages'
            ? RestauImagesGetPayload<S['include'][P]> | null
            : P extends 'Restaurant'
            ? RestaurantGetPayload<S['include'][P]> | null
            : P extends '_count'
            ? RestauUserCountOutputTypeGetPayload<S['include'][P]>
            : never;
        }
      : 'select' extends U
      ? {
          [P in TrueKeys<S['select']>]: P extends keyof RestauUser
            ? RestauUser[P]
            : P extends 'Token'
            ? Array<RestauTokensGetPayload<S['select'][P]>>
            : P extends 'RestauImages'
            ? RestauImagesGetPayload<S['select'][P]> | null
            : P extends 'Restaurant'
            ? RestaurantGetPayload<S['select'][P]> | null
            : P extends '_count'
            ? RestauUserCountOutputTypeGetPayload<S['select'][P]>
            : never;
        }
      : RestauUser
    : RestauUser;

  type RestauUserCountArgs = Merge<
    Omit<RestauUserFindManyArgs, 'select' | 'include'> & {
      select?: RestauUserCountAggregateInputType | true;
    }
  >;

  export interface RestauUserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one RestauUser that matches the filter.
     * @param {RestauUserFindUniqueArgs} args - Arguments to find a RestauUser
     * @example
     * // Get one RestauUser
     * const restauUser = await prisma.restauUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUnique<
      T extends RestauUserFindUniqueArgs,
      LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound
        ? T['rejectOnNotFound']
        : undefined
    >(
      args: SelectSubset<T, RestauUserFindUniqueArgs>
    ): HasReject<
      GlobalRejectSettings,
      LocalRejectSettings,
      'findUnique',
      'RestauUser'
    > extends True
      ? CheckSelect<
          T,
          Prisma__RestauUserClient<RestauUser>,
          Prisma__RestauUserClient<RestauUserGetPayload<T>>
        >
      : CheckSelect<
          T,
          Prisma__RestauUserClient<RestauUser | null>,
          Prisma__RestauUserClient<RestauUserGetPayload<T> | null>
        >;

    /**
     * Find the first RestauUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestauUserFindFirstArgs} args - Arguments to find a RestauUser
     * @example
     * // Get one RestauUser
     * const restauUser = await prisma.restauUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirst<
      T extends RestauUserFindFirstArgs,
      LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound
        ? T['rejectOnNotFound']
        : undefined
    >(
      args?: SelectSubset<T, RestauUserFindFirstArgs>
    ): HasReject<
      GlobalRejectSettings,
      LocalRejectSettings,
      'findFirst',
      'RestauUser'
    > extends True
      ? CheckSelect<
          T,
          Prisma__RestauUserClient<RestauUser>,
          Prisma__RestauUserClient<RestauUserGetPayload<T>>
        >
      : CheckSelect<
          T,
          Prisma__RestauUserClient<RestauUser | null>,
          Prisma__RestauUserClient<RestauUserGetPayload<T> | null>
        >;

    /**
     * Find zero or more RestauUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestauUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RestauUsers
     * const restauUsers = await prisma.restauUser.findMany()
     *
     * // Get first 10 RestauUsers
     * const restauUsers = await prisma.restauUser.findMany({ take: 10 })
     *
     * // Only select the `restauUserId`
     * const restauUserWithRestauUserIdOnly = await prisma.restauUser.findMany({ select: { restauUserId: true } })
     *
     **/
    findMany<T extends RestauUserFindManyArgs>(
      args?: SelectSubset<T, RestauUserFindManyArgs>
    ): CheckSelect<
      T,
      PrismaPromise<Array<RestauUser>>,
      PrismaPromise<Array<RestauUserGetPayload<T>>>
    >;

    /**
     * Create a RestauUser.
     * @param {RestauUserCreateArgs} args - Arguments to create a RestauUser.
     * @example
     * // Create one RestauUser
     * const RestauUser = await prisma.restauUser.create({
     *   data: {
     *     // ... data to create a RestauUser
     *   }
     * })
     *
     **/
    create<T extends RestauUserCreateArgs>(
      args: SelectSubset<T, RestauUserCreateArgs>
    ): CheckSelect<
      T,
      Prisma__RestauUserClient<RestauUser>,
      Prisma__RestauUserClient<RestauUserGetPayload<T>>
    >;

    /**
     * Create many RestauUsers.
     *     @param {RestauUserCreateManyArgs} args - Arguments to create many RestauUsers.
     *     @example
     *     // Create many RestauUsers
     *     const restauUser = await prisma.restauUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
     **/
    createMany<T extends RestauUserCreateManyArgs>(
      args?: SelectSubset<T, RestauUserCreateManyArgs>
    ): PrismaPromise<BatchPayload>;

    /**
     * Delete a RestauUser.
     * @param {RestauUserDeleteArgs} args - Arguments to delete one RestauUser.
     * @example
     * // Delete one RestauUser
     * const RestauUser = await prisma.restauUser.delete({
     *   where: {
     *     // ... filter to delete one RestauUser
     *   }
     * })
     *
     **/
    delete<T extends RestauUserDeleteArgs>(
      args: SelectSubset<T, RestauUserDeleteArgs>
    ): CheckSelect<
      T,
      Prisma__RestauUserClient<RestauUser>,
      Prisma__RestauUserClient<RestauUserGetPayload<T>>
    >;

    /**
     * Update one RestauUser.
     * @param {RestauUserUpdateArgs} args - Arguments to update one RestauUser.
     * @example
     * // Update one RestauUser
     * const restauUser = await prisma.restauUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    update<T extends RestauUserUpdateArgs>(
      args: SelectSubset<T, RestauUserUpdateArgs>
    ): CheckSelect<
      T,
      Prisma__RestauUserClient<RestauUser>,
      Prisma__RestauUserClient<RestauUserGetPayload<T>>
    >;

    /**
     * Delete zero or more RestauUsers.
     * @param {RestauUserDeleteManyArgs} args - Arguments to filter RestauUsers to delete.
     * @example
     * // Delete a few RestauUsers
     * const { count } = await prisma.restauUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     **/
    deleteMany<T extends RestauUserDeleteManyArgs>(
      args?: SelectSubset<T, RestauUserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>;

    /**
     * Update zero or more RestauUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestauUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RestauUsers
     * const restauUser = await prisma.restauUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    updateMany<T extends RestauUserUpdateManyArgs>(
      args: SelectSubset<T, RestauUserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>;

    /**
     * Create or update one RestauUser.
     * @param {RestauUserUpsertArgs} args - Arguments to update or create a RestauUser.
     * @example
     * // Update or create a RestauUser
     * const restauUser = await prisma.restauUser.upsert({
     *   create: {
     *     // ... data to create a RestauUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RestauUser we want to update
     *   }
     * })
     **/
    upsert<T extends RestauUserUpsertArgs>(
      args: SelectSubset<T, RestauUserUpsertArgs>
    ): CheckSelect<
      T,
      Prisma__RestauUserClient<RestauUser>,
      Prisma__RestauUserClient<RestauUserGetPayload<T>>
    >;

    /**
     * Count the number of RestauUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestauUserCountArgs} args - Arguments to filter RestauUsers to count.
     * @example
     * // Count the number of RestauUsers
     * const count = await prisma.restauUser.count({
     *   where: {
     *     // ... the filter for the RestauUsers we want to count
     *   }
     * })
     **/
    count<T extends RestauUserCountArgs>(
      args?: Subset<T, RestauUserCountArgs>
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RestauUserCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a RestauUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestauUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends RestauUserAggregateArgs>(
      args: Subset<T, RestauUserAggregateArgs>
    ): PrismaPromise<GetRestauUserAggregateType<T>>;

    /**
     * Group by RestauUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestauUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends RestauUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RestauUserGroupByArgs['orderBy'] }
        : { orderBy?: RestauUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  'Field ',
                  P,
                  ` in "having" needs to be provided in "by"`
                ];
          }[HavingFields]
        : 'take' extends Keys<T>
        ? 'orderBy' extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : 'skip' extends Keys<T>
        ? 'orderBy' extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "skip", you also need to provide "orderBy"'
        : ByValid extends True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
          }[OrderFields]
    >(
      args: SubsetIntersection<T, RestauUserGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetRestauUserGroupByPayload<T>
      : Promise<InputErrors>;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RestauUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RestauUserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(
      _dmmf: runtime.DMMFClass,
      _fetcher: PrismaClientFetcher,
      _queryType: 'query' | 'mutation',
      _rootField: string,
      _clientMethod: string,
      _args: any,
      _dataPath: string[],
      _errorFormat: ErrorFormat,
      _measurePerformance?: boolean | undefined,
      _isList?: boolean
    );
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Token<T extends RestauTokensFindManyArgs = {}>(
      args?: Subset<T, RestauTokensFindManyArgs>
    ): CheckSelect<
      T,
      PrismaPromise<Array<RestauTokens>>,
      PrismaPromise<Array<RestauTokensGetPayload<T>>>
    >;

    RestauImages<T extends RestauImagesArgs = {}>(
      args?: Subset<T, RestauImagesArgs>
    ): CheckSelect<
      T,
      Prisma__RestauImagesClient<RestauImages | null>,
      Prisma__RestauImagesClient<RestauImagesGetPayload<T> | null>
    >;

    Restaurant<T extends RestaurantArgs = {}>(
      args?: Subset<T, RestaurantArgs>
    ): CheckSelect<
      T,
      Prisma__RestaurantClient<Restaurant | null>,
      Prisma__RestaurantClient<RestaurantGetPayload<T> | null>
    >;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * RestauUser findUnique
   */
  export type RestauUserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the RestauUser
     *
     **/
    select?: RestauUserSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RestauUserInclude | null;
    /**
     * Throw an Error if a RestauUser can't be found
     *
     **/
    rejectOnNotFound?: RejectOnNotFound;
    /**
     * Filter, which RestauUser to fetch.
     *
     **/
    where: RestauUserWhereUniqueInput;
  };

  /**
   * RestauUser findFirst
   */
  export type RestauUserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the RestauUser
     *
     **/
    select?: RestauUserSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RestauUserInclude | null;
    /**
     * Throw an Error if a RestauUser can't be found
     *
     **/
    rejectOnNotFound?: RejectOnNotFound;
    /**
     * Filter, which RestauUser to fetch.
     *
     **/
    where?: RestauUserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RestauUsers to fetch.
     *
     **/
    orderBy?: Enumerable<RestauUserOrderByWithRelationInput>;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for RestauUsers.
     *
     **/
    cursor?: RestauUserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RestauUsers from the position of the cursor.
     *
     **/
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RestauUsers.
     *
     **/
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of RestauUsers.
     *
     **/
    distinct?: Enumerable<RestauUserScalarFieldEnum>;
  };

  /**
   * RestauUser findMany
   */
  export type RestauUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the RestauUser
     *
     **/
    select?: RestauUserSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RestauUserInclude | null;
    /**
     * Filter, which RestauUsers to fetch.
     *
     **/
    where?: RestauUserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RestauUsers to fetch.
     *
     **/
    orderBy?: Enumerable<RestauUserOrderByWithRelationInput>;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing RestauUsers.
     *
     **/
    cursor?: RestauUserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RestauUsers from the position of the cursor.
     *
     **/
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RestauUsers.
     *
     **/
    skip?: number;
    distinct?: Enumerable<RestauUserScalarFieldEnum>;
  };

  /**
   * RestauUser create
   */
  export type RestauUserCreateArgs = {
    /**
     * Select specific fields to fetch from the RestauUser
     *
     **/
    select?: RestauUserSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RestauUserInclude | null;
    /**
     * The data needed to create a RestauUser.
     *
     **/
    data: XOR<RestauUserCreateInput, RestauUserUncheckedCreateInput>;
  };

  /**
   * RestauUser createMany
   */
  export type RestauUserCreateManyArgs = {
    /**
     * The data used to create many RestauUsers.
     *
     **/
    data: Enumerable<RestauUserCreateManyInput>;
    skipDuplicates?: boolean;
  };

  /**
   * RestauUser update
   */
  export type RestauUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the RestauUser
     *
     **/
    select?: RestauUserSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RestauUserInclude | null;
    /**
     * The data needed to update a RestauUser.
     *
     **/
    data: XOR<RestauUserUpdateInput, RestauUserUncheckedUpdateInput>;
    /**
     * Choose, which RestauUser to update.
     *
     **/
    where: RestauUserWhereUniqueInput;
  };

  /**
   * RestauUser updateMany
   */
  export type RestauUserUpdateManyArgs = {
    /**
     * The data used to update RestauUsers.
     *
     **/
    data: XOR<
      RestauUserUpdateManyMutationInput,
      RestauUserUncheckedUpdateManyInput
    >;
    /**
     * Filter which RestauUsers to update
     *
     **/
    where?: RestauUserWhereInput;
  };

  /**
   * RestauUser upsert
   */
  export type RestauUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the RestauUser
     *
     **/
    select?: RestauUserSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RestauUserInclude | null;
    /**
     * The filter to search for the RestauUser to update in case it exists.
     *
     **/
    where: RestauUserWhereUniqueInput;
    /**
     * In case the RestauUser found by the `where` argument doesn't exist, create a new RestauUser with this data.
     *
     **/
    create: XOR<RestauUserCreateInput, RestauUserUncheckedCreateInput>;
    /**
     * In case the RestauUser was found with the provided `where` argument, update it with this data.
     *
     **/
    update: XOR<RestauUserUpdateInput, RestauUserUncheckedUpdateInput>;
  };

  /**
   * RestauUser delete
   */
  export type RestauUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the RestauUser
     *
     **/
    select?: RestauUserSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RestauUserInclude | null;
    /**
     * Filter which RestauUser to delete.
     *
     **/
    where: RestauUserWhereUniqueInput;
  };

  /**
   * RestauUser deleteMany
   */
  export type RestauUserDeleteManyArgs = {
    /**
     * Filter which RestauUsers to delete
     *
     **/
    where?: RestauUserWhereInput;
  };

  /**
   * RestauUser without action
   */
  export type RestauUserArgs = {
    /**
     * Select specific fields to fetch from the RestauUser
     *
     **/
    select?: RestauUserSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RestauUserInclude | null;
  };

  /**
   * Model RestauImages
   */

  export type AggregateRestauImages = {
    _count: RestauImagesCountAggregateOutputType | null;
    _min: RestauImagesMinAggregateOutputType | null;
    _max: RestauImagesMaxAggregateOutputType | null;
  };

  export type RestauImagesMinAggregateOutputType = {
    imageId: string | null;
    address: string | null;
    publicUrl: string | null;
    imageUrl: string | null;
    restauId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type RestauImagesMaxAggregateOutputType = {
    imageId: string | null;
    address: string | null;
    publicUrl: string | null;
    imageUrl: string | null;
    restauId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type RestauImagesCountAggregateOutputType = {
    imageId: number;
    address: number;
    publicUrl: number;
    imageUrl: number;
    restauId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type RestauImagesMinAggregateInputType = {
    imageId?: true;
    address?: true;
    publicUrl?: true;
    imageUrl?: true;
    restauId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type RestauImagesMaxAggregateInputType = {
    imageId?: true;
    address?: true;
    publicUrl?: true;
    imageUrl?: true;
    restauId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type RestauImagesCountAggregateInputType = {
    imageId?: true;
    address?: true;
    publicUrl?: true;
    imageUrl?: true;
    restauId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type RestauImagesAggregateArgs = {
    /**
     * Filter which RestauImages to aggregate.
     *
     **/
    where?: RestauImagesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RestauImages to fetch.
     *
     **/
    orderBy?: Enumerable<RestauImagesOrderByWithRelationInput>;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     *
     **/
    cursor?: RestauImagesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RestauImages from the position of the cursor.
     *
     **/
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RestauImages.
     *
     **/
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned RestauImages
     **/
    _count?: true | RestauImagesCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: RestauImagesMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: RestauImagesMaxAggregateInputType;
  };

  export type GetRestauImagesAggregateType<
    T extends RestauImagesAggregateArgs
  > = {
    [P in keyof T & keyof AggregateRestauImages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRestauImages[P]>
      : GetScalarType<T[P], AggregateRestauImages[P]>;
  };

  export type RestauImagesGroupByArgs = {
    where?: RestauImagesWhereInput;
    orderBy?: Enumerable<RestauImagesOrderByWithAggregationInput>;
    by: Array<RestauImagesScalarFieldEnum>;
    having?: RestauImagesScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: RestauImagesCountAggregateInputType | true;
    _min?: RestauImagesMinAggregateInputType;
    _max?: RestauImagesMaxAggregateInputType;
  };

  export type RestauImagesGroupByOutputType = {
    imageId: string;
    address: string;
    publicUrl: string;
    imageUrl: string;
    restauId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    _count: RestauImagesCountAggregateOutputType | null;
    _min: RestauImagesMinAggregateOutputType | null;
    _max: RestauImagesMaxAggregateOutputType | null;
  };

  type GetRestauImagesGroupByPayload<T extends RestauImagesGroupByArgs> =
    Promise<
      Array<
        PickArray<RestauImagesGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof RestauImagesGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RestauImagesGroupByOutputType[P]>
            : GetScalarType<T[P], RestauImagesGroupByOutputType[P]>;
        }
      >
    >;

  export type RestauImagesSelect = {
    imageId?: boolean;
    address?: boolean;
    publicUrl?: boolean;
    imageUrl?: boolean;
    restauId?: boolean;
    Restaurant?: boolean | RestaurantFindManyArgs;
    RestauUser?: boolean | RestauUserFindManyArgs;
    createdAt?: boolean;
    updatedAt?: boolean;
    _count?: boolean | RestauImagesCountOutputTypeArgs;
  };

  export type RestauImagesInclude = {
    Restaurant?: boolean | RestaurantFindManyArgs;
    RestauUser?: boolean | RestauUserFindManyArgs;
    _count?: boolean | RestauImagesCountOutputTypeArgs;
  };

  export type RestauImagesGetPayload<
    S extends boolean | null | undefined | RestauImagesArgs,
    U = keyof S
  > = S extends true
    ? RestauImages
    : S extends undefined
    ? never
    : S extends RestauImagesArgs | RestauImagesFindManyArgs
    ? 'include' extends U
      ? RestauImages & {
          [P in TrueKeys<S['include']>]: P extends 'Restaurant'
            ? Array<RestaurantGetPayload<S['include'][P]>>
            : P extends 'RestauUser'
            ? Array<RestauUserGetPayload<S['include'][P]>>
            : P extends '_count'
            ? RestauImagesCountOutputTypeGetPayload<S['include'][P]>
            : never;
        }
      : 'select' extends U
      ? {
          [P in TrueKeys<S['select']>]: P extends keyof RestauImages
            ? RestauImages[P]
            : P extends 'Restaurant'
            ? Array<RestaurantGetPayload<S['select'][P]>>
            : P extends 'RestauUser'
            ? Array<RestauUserGetPayload<S['select'][P]>>
            : P extends '_count'
            ? RestauImagesCountOutputTypeGetPayload<S['select'][P]>
            : never;
        }
      : RestauImages
    : RestauImages;

  type RestauImagesCountArgs = Merge<
    Omit<RestauImagesFindManyArgs, 'select' | 'include'> & {
      select?: RestauImagesCountAggregateInputType | true;
    }
  >;

  export interface RestauImagesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one RestauImages that matches the filter.
     * @param {RestauImagesFindUniqueArgs} args - Arguments to find a RestauImages
     * @example
     * // Get one RestauImages
     * const restauImages = await prisma.restauImages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUnique<
      T extends RestauImagesFindUniqueArgs,
      LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound
        ? T['rejectOnNotFound']
        : undefined
    >(
      args: SelectSubset<T, RestauImagesFindUniqueArgs>
    ): HasReject<
      GlobalRejectSettings,
      LocalRejectSettings,
      'findUnique',
      'RestauImages'
    > extends True
      ? CheckSelect<
          T,
          Prisma__RestauImagesClient<RestauImages>,
          Prisma__RestauImagesClient<RestauImagesGetPayload<T>>
        >
      : CheckSelect<
          T,
          Prisma__RestauImagesClient<RestauImages | null>,
          Prisma__RestauImagesClient<RestauImagesGetPayload<T> | null>
        >;

    /**
     * Find the first RestauImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestauImagesFindFirstArgs} args - Arguments to find a RestauImages
     * @example
     * // Get one RestauImages
     * const restauImages = await prisma.restauImages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirst<
      T extends RestauImagesFindFirstArgs,
      LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound
        ? T['rejectOnNotFound']
        : undefined
    >(
      args?: SelectSubset<T, RestauImagesFindFirstArgs>
    ): HasReject<
      GlobalRejectSettings,
      LocalRejectSettings,
      'findFirst',
      'RestauImages'
    > extends True
      ? CheckSelect<
          T,
          Prisma__RestauImagesClient<RestauImages>,
          Prisma__RestauImagesClient<RestauImagesGetPayload<T>>
        >
      : CheckSelect<
          T,
          Prisma__RestauImagesClient<RestauImages | null>,
          Prisma__RestauImagesClient<RestauImagesGetPayload<T> | null>
        >;

    /**
     * Find zero or more RestauImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestauImagesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RestauImages
     * const restauImages = await prisma.restauImages.findMany()
     *
     * // Get first 10 RestauImages
     * const restauImages = await prisma.restauImages.findMany({ take: 10 })
     *
     * // Only select the `imageId`
     * const restauImagesWithImageIdOnly = await prisma.restauImages.findMany({ select: { imageId: true } })
     *
     **/
    findMany<T extends RestauImagesFindManyArgs>(
      args?: SelectSubset<T, RestauImagesFindManyArgs>
    ): CheckSelect<
      T,
      PrismaPromise<Array<RestauImages>>,
      PrismaPromise<Array<RestauImagesGetPayload<T>>>
    >;

    /**
     * Create a RestauImages.
     * @param {RestauImagesCreateArgs} args - Arguments to create a RestauImages.
     * @example
     * // Create one RestauImages
     * const RestauImages = await prisma.restauImages.create({
     *   data: {
     *     // ... data to create a RestauImages
     *   }
     * })
     *
     **/
    create<T extends RestauImagesCreateArgs>(
      args: SelectSubset<T, RestauImagesCreateArgs>
    ): CheckSelect<
      T,
      Prisma__RestauImagesClient<RestauImages>,
      Prisma__RestauImagesClient<RestauImagesGetPayload<T>>
    >;

    /**
     * Create many RestauImages.
     *     @param {RestauImagesCreateManyArgs} args - Arguments to create many RestauImages.
     *     @example
     *     // Create many RestauImages
     *     const restauImages = await prisma.restauImages.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
     **/
    createMany<T extends RestauImagesCreateManyArgs>(
      args?: SelectSubset<T, RestauImagesCreateManyArgs>
    ): PrismaPromise<BatchPayload>;

    /**
     * Delete a RestauImages.
     * @param {RestauImagesDeleteArgs} args - Arguments to delete one RestauImages.
     * @example
     * // Delete one RestauImages
     * const RestauImages = await prisma.restauImages.delete({
     *   where: {
     *     // ... filter to delete one RestauImages
     *   }
     * })
     *
     **/
    delete<T extends RestauImagesDeleteArgs>(
      args: SelectSubset<T, RestauImagesDeleteArgs>
    ): CheckSelect<
      T,
      Prisma__RestauImagesClient<RestauImages>,
      Prisma__RestauImagesClient<RestauImagesGetPayload<T>>
    >;

    /**
     * Update one RestauImages.
     * @param {RestauImagesUpdateArgs} args - Arguments to update one RestauImages.
     * @example
     * // Update one RestauImages
     * const restauImages = await prisma.restauImages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    update<T extends RestauImagesUpdateArgs>(
      args: SelectSubset<T, RestauImagesUpdateArgs>
    ): CheckSelect<
      T,
      Prisma__RestauImagesClient<RestauImages>,
      Prisma__RestauImagesClient<RestauImagesGetPayload<T>>
    >;

    /**
     * Delete zero or more RestauImages.
     * @param {RestauImagesDeleteManyArgs} args - Arguments to filter RestauImages to delete.
     * @example
     * // Delete a few RestauImages
     * const { count } = await prisma.restauImages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     **/
    deleteMany<T extends RestauImagesDeleteManyArgs>(
      args?: SelectSubset<T, RestauImagesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>;

    /**
     * Update zero or more RestauImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestauImagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RestauImages
     * const restauImages = await prisma.restauImages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    updateMany<T extends RestauImagesUpdateManyArgs>(
      args: SelectSubset<T, RestauImagesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>;

    /**
     * Create or update one RestauImages.
     * @param {RestauImagesUpsertArgs} args - Arguments to update or create a RestauImages.
     * @example
     * // Update or create a RestauImages
     * const restauImages = await prisma.restauImages.upsert({
     *   create: {
     *     // ... data to create a RestauImages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RestauImages we want to update
     *   }
     * })
     **/
    upsert<T extends RestauImagesUpsertArgs>(
      args: SelectSubset<T, RestauImagesUpsertArgs>
    ): CheckSelect<
      T,
      Prisma__RestauImagesClient<RestauImages>,
      Prisma__RestauImagesClient<RestauImagesGetPayload<T>>
    >;

    /**
     * Count the number of RestauImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestauImagesCountArgs} args - Arguments to filter RestauImages to count.
     * @example
     * // Count the number of RestauImages
     * const count = await prisma.restauImages.count({
     *   where: {
     *     // ... the filter for the RestauImages we want to count
     *   }
     * })
     **/
    count<T extends RestauImagesCountArgs>(
      args?: Subset<T, RestauImagesCountArgs>
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RestauImagesCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a RestauImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestauImagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends RestauImagesAggregateArgs>(
      args: Subset<T, RestauImagesAggregateArgs>
    ): PrismaPromise<GetRestauImagesAggregateType<T>>;

    /**
     * Group by RestauImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestauImagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends RestauImagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RestauImagesGroupByArgs['orderBy'] }
        : { orderBy?: RestauImagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  'Field ',
                  P,
                  ` in "having" needs to be provided in "by"`
                ];
          }[HavingFields]
        : 'take' extends Keys<T>
        ? 'orderBy' extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : 'skip' extends Keys<T>
        ? 'orderBy' extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "skip", you also need to provide "orderBy"'
        : ByValid extends True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
          }[OrderFields]
    >(
      args: SubsetIntersection<T, RestauImagesGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetRestauImagesGroupByPayload<T>
      : Promise<InputErrors>;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RestauImages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RestauImagesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(
      _dmmf: runtime.DMMFClass,
      _fetcher: PrismaClientFetcher,
      _queryType: 'query' | 'mutation',
      _rootField: string,
      _clientMethod: string,
      _args: any,
      _dataPath: string[],
      _errorFormat: ErrorFormat,
      _measurePerformance?: boolean | undefined,
      _isList?: boolean
    );
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Restaurant<T extends RestaurantFindManyArgs = {}>(
      args?: Subset<T, RestaurantFindManyArgs>
    ): CheckSelect<
      T,
      PrismaPromise<Array<Restaurant>>,
      PrismaPromise<Array<RestaurantGetPayload<T>>>
    >;

    RestauUser<T extends RestauUserFindManyArgs = {}>(
      args?: Subset<T, RestauUserFindManyArgs>
    ): CheckSelect<
      T,
      PrismaPromise<Array<RestauUser>>,
      PrismaPromise<Array<RestauUserGetPayload<T>>>
    >;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * RestauImages findUnique
   */
  export type RestauImagesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the RestauImages
     *
     **/
    select?: RestauImagesSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RestauImagesInclude | null;
    /**
     * Throw an Error if a RestauImages can't be found
     *
     **/
    rejectOnNotFound?: RejectOnNotFound;
    /**
     * Filter, which RestauImages to fetch.
     *
     **/
    where: RestauImagesWhereUniqueInput;
  };

  /**
   * RestauImages findFirst
   */
  export type RestauImagesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the RestauImages
     *
     **/
    select?: RestauImagesSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RestauImagesInclude | null;
    /**
     * Throw an Error if a RestauImages can't be found
     *
     **/
    rejectOnNotFound?: RejectOnNotFound;
    /**
     * Filter, which RestauImages to fetch.
     *
     **/
    where?: RestauImagesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RestauImages to fetch.
     *
     **/
    orderBy?: Enumerable<RestauImagesOrderByWithRelationInput>;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for RestauImages.
     *
     **/
    cursor?: RestauImagesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RestauImages from the position of the cursor.
     *
     **/
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RestauImages.
     *
     **/
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of RestauImages.
     *
     **/
    distinct?: Enumerable<RestauImagesScalarFieldEnum>;
  };

  /**
   * RestauImages findMany
   */
  export type RestauImagesFindManyArgs = {
    /**
     * Select specific fields to fetch from the RestauImages
     *
     **/
    select?: RestauImagesSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RestauImagesInclude | null;
    /**
     * Filter, which RestauImages to fetch.
     *
     **/
    where?: RestauImagesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RestauImages to fetch.
     *
     **/
    orderBy?: Enumerable<RestauImagesOrderByWithRelationInput>;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing RestauImages.
     *
     **/
    cursor?: RestauImagesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RestauImages from the position of the cursor.
     *
     **/
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RestauImages.
     *
     **/
    skip?: number;
    distinct?: Enumerable<RestauImagesScalarFieldEnum>;
  };

  /**
   * RestauImages create
   */
  export type RestauImagesCreateArgs = {
    /**
     * Select specific fields to fetch from the RestauImages
     *
     **/
    select?: RestauImagesSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RestauImagesInclude | null;
    /**
     * The data needed to create a RestauImages.
     *
     **/
    data: XOR<RestauImagesCreateInput, RestauImagesUncheckedCreateInput>;
  };

  /**
   * RestauImages createMany
   */
  export type RestauImagesCreateManyArgs = {
    /**
     * The data used to create many RestauImages.
     *
     **/
    data: Enumerable<RestauImagesCreateManyInput>;
    skipDuplicates?: boolean;
  };

  /**
   * RestauImages update
   */
  export type RestauImagesUpdateArgs = {
    /**
     * Select specific fields to fetch from the RestauImages
     *
     **/
    select?: RestauImagesSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RestauImagesInclude | null;
    /**
     * The data needed to update a RestauImages.
     *
     **/
    data: XOR<RestauImagesUpdateInput, RestauImagesUncheckedUpdateInput>;
    /**
     * Choose, which RestauImages to update.
     *
     **/
    where: RestauImagesWhereUniqueInput;
  };

  /**
   * RestauImages updateMany
   */
  export type RestauImagesUpdateManyArgs = {
    /**
     * The data used to update RestauImages.
     *
     **/
    data: XOR<
      RestauImagesUpdateManyMutationInput,
      RestauImagesUncheckedUpdateManyInput
    >;
    /**
     * Filter which RestauImages to update
     *
     **/
    where?: RestauImagesWhereInput;
  };

  /**
   * RestauImages upsert
   */
  export type RestauImagesUpsertArgs = {
    /**
     * Select specific fields to fetch from the RestauImages
     *
     **/
    select?: RestauImagesSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RestauImagesInclude | null;
    /**
     * The filter to search for the RestauImages to update in case it exists.
     *
     **/
    where: RestauImagesWhereUniqueInput;
    /**
     * In case the RestauImages found by the `where` argument doesn't exist, create a new RestauImages with this data.
     *
     **/
    create: XOR<RestauImagesCreateInput, RestauImagesUncheckedCreateInput>;
    /**
     * In case the RestauImages was found with the provided `where` argument, update it with this data.
     *
     **/
    update: XOR<RestauImagesUpdateInput, RestauImagesUncheckedUpdateInput>;
  };

  /**
   * RestauImages delete
   */
  export type RestauImagesDeleteArgs = {
    /**
     * Select specific fields to fetch from the RestauImages
     *
     **/
    select?: RestauImagesSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RestauImagesInclude | null;
    /**
     * Filter which RestauImages to delete.
     *
     **/
    where: RestauImagesWhereUniqueInput;
  };

  /**
   * RestauImages deleteMany
   */
  export type RestauImagesDeleteManyArgs = {
    /**
     * Filter which RestauImages to delete
     *
     **/
    where?: RestauImagesWhereInput;
  };

  /**
   * RestauImages without action
   */
  export type RestauImagesArgs = {
    /**
     * Select specific fields to fetch from the RestauImages
     *
     **/
    select?: RestauImagesSelect | null;
    /**
     * Choose, which related nodes to fetch as well.
     *
     **/
    include?: RestauImagesInclude | null;
  };

  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const UserScalarFieldEnum: {
    userId: 'userId';
    phoneNumber: 'phoneNumber';
    isPhoneConfirmed: 'isPhoneConfirmed';
    username: 'username';
    password: 'password';
    completeName: 'completeName';
    userRoleId: 'userRoleId';
    userAddressId: 'userAddressId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type UserScalarFieldEnum =
    typeof UserScalarFieldEnum[keyof typeof UserScalarFieldEnum];

  export const TokensScalarFieldEnum: {
    tokenId: 'tokenId';
    token: 'token';
    userId: 'userId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type TokensScalarFieldEnum =
    typeof TokensScalarFieldEnum[keyof typeof TokensScalarFieldEnum];

  export const RoleScalarFieldEnum: {
    roleId: 'roleId';
    userRole: 'userRole';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type RoleScalarFieldEnum =
    typeof RoleScalarFieldEnum[keyof typeof RoleScalarFieldEnum];

  export const AddressScalarFieldEnum: {
    addressId: 'addressId';
    commune: 'commune';
    address: 'address';
    longitude: 'longitude';
    latitude: 'latitude';
    restauId: 'restauId';
    userId: 'userId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type AddressScalarFieldEnum =
    typeof AddressScalarFieldEnum[keyof typeof AddressScalarFieldEnum];

  export const RestaurantScalarFieldEnum: {
    restauId: 'restauId';
    restauName: 'restauName';
    restauDescription: 'restauDescription';
    phoneNumber: 'phoneNumber';
    email: 'email';
    restauAddressId: 'restauAddressId';
    mainImageId: 'mainImageId';
    isActive: 'isActive';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type RestaurantScalarFieldEnum =
    typeof RestaurantScalarFieldEnum[keyof typeof RestaurantScalarFieldEnum];

  export const RestauTokensScalarFieldEnum: {
    tokenId: 'tokenId';
    token: 'token';
    restauUserId: 'restauUserId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type RestauTokensScalarFieldEnum =
    typeof RestauTokensScalarFieldEnum[keyof typeof RestauTokensScalarFieldEnum];

  export const RestauUserScalarFieldEnum: {
    restauUserId: 'restauUserId';
    restauId: 'restauId';
    userName: 'userName';
    phoneNumber: 'phoneNumber';
    completeName: 'completeName';
    userImage: 'userImage';
    password: 'password';
    role: 'role';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type RestauUserScalarFieldEnum =
    typeof RestauUserScalarFieldEnum[keyof typeof RestauUserScalarFieldEnum];

  export const RestauImagesScalarFieldEnum: {
    imageId: 'imageId';
    address: 'address';
    publicUrl: 'publicUrl';
    imageUrl: 'imageUrl';
    restauId: 'restauId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type RestauImagesScalarFieldEnum =
    typeof RestauImagesScalarFieldEnum[keyof typeof RestauImagesScalarFieldEnum];

  export const SortOrder: {
    asc: 'asc';
    desc: 'desc';
  };

  export type SortOrder = typeof SortOrder[keyof typeof SortOrder];

  /**
   * Deep Input Types
   */

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>;
    OR?: Enumerable<UserWhereInput>;
    NOT?: Enumerable<UserWhereInput>;
    userId?: StringFilter | string;
    phoneNumber?: StringFilter | string;
    isPhoneConfirmed?: BoolFilter | boolean;
    username?: StringFilter | string;
    password?: StringFilter | string;
    completeName?: StringNullableFilter | string | null;
    Role?: XOR<RoleRelationFilter, RoleWhereInput>;
    Token?: TokensListRelationFilter;
    UserAddress?: XOR<AddressRelationFilter, AddressWhereInput> | null;
    userRoleId?: StringFilter | string;
    userAddressId?: StringNullableFilter | string | null;
    createdAt?: DateTimeNullableFilter | Date | string | null;
    updatedAt?: DateTimeNullableFilter | Date | string | null;
  };

  export type UserOrderByWithRelationInput = {
    userId?: SortOrder;
    phoneNumber?: SortOrder;
    isPhoneConfirmed?: SortOrder;
    username?: SortOrder;
    password?: SortOrder;
    completeName?: SortOrder;
    Role?: RoleOrderByWithRelationInput;
    Token?: TokensOrderByRelationAggregateInput;
    UserAddress?: AddressOrderByWithRelationInput;
    userRoleId?: SortOrder;
    userAddressId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type UserWhereUniqueInput = {
    userId?: string;
    phoneNumber?: string;
    username?: string;
  };

  export type UserOrderByWithAggregationInput = {
    userId?: SortOrder;
    phoneNumber?: SortOrder;
    isPhoneConfirmed?: SortOrder;
    username?: SortOrder;
    password?: SortOrder;
    completeName?: SortOrder;
    userRoleId?: SortOrder;
    userAddressId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: UserCountOrderByAggregateInput;
    _max?: UserMaxOrderByAggregateInput;
    _min?: UserMinOrderByAggregateInput;
  };

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>;
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>;
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>;
    userId?: StringWithAggregatesFilter | string;
    phoneNumber?: StringWithAggregatesFilter | string;
    isPhoneConfirmed?: BoolWithAggregatesFilter | boolean;
    username?: StringWithAggregatesFilter | string;
    password?: StringWithAggregatesFilter | string;
    completeName?: StringNullableWithAggregatesFilter | string | null;
    userRoleId?: StringWithAggregatesFilter | string;
    userAddressId?: StringNullableWithAggregatesFilter | string | null;
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null;
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null;
  };

  export type TokensWhereInput = {
    AND?: Enumerable<TokensWhereInput>;
    OR?: Enumerable<TokensWhereInput>;
    NOT?: Enumerable<TokensWhereInput>;
    tokenId?: StringFilter | string;
    token?: StringFilter | string;
    userId?: StringFilter | string;
    User?: XOR<UserRelationFilter, UserWhereInput>;
    createdAt?: DateTimeNullableFilter | Date | string | null;
    updatedAt?: DateTimeNullableFilter | Date | string | null;
  };

  export type TokensOrderByWithRelationInput = {
    tokenId?: SortOrder;
    token?: SortOrder;
    userId?: SortOrder;
    User?: UserOrderByWithRelationInput;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type TokensWhereUniqueInput = {
    tokenId?: string;
  };

  export type TokensOrderByWithAggregationInput = {
    tokenId?: SortOrder;
    token?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: TokensCountOrderByAggregateInput;
    _max?: TokensMaxOrderByAggregateInput;
    _min?: TokensMinOrderByAggregateInput;
  };

  export type TokensScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TokensScalarWhereWithAggregatesInput>;
    OR?: Enumerable<TokensScalarWhereWithAggregatesInput>;
    NOT?: Enumerable<TokensScalarWhereWithAggregatesInput>;
    tokenId?: StringWithAggregatesFilter | string;
    token?: StringWithAggregatesFilter | string;
    userId?: StringWithAggregatesFilter | string;
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null;
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null;
  };

  export type RoleWhereInput = {
    AND?: Enumerable<RoleWhereInput>;
    OR?: Enumerable<RoleWhereInput>;
    NOT?: Enumerable<RoleWhereInput>;
    roleId?: StringFilter | string;
    userRole?: StringFilter | string;
    User?: UserListRelationFilter;
    createdAt?: DateTimeNullableFilter | Date | string | null;
    updatedAt?: DateTimeNullableFilter | Date | string | null;
  };

  export type RoleOrderByWithRelationInput = {
    roleId?: SortOrder;
    userRole?: SortOrder;
    User?: UserOrderByRelationAggregateInput;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RoleWhereUniqueInput = {
    roleId?: string;
  };

  export type RoleOrderByWithAggregationInput = {
    roleId?: SortOrder;
    userRole?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: RoleCountOrderByAggregateInput;
    _max?: RoleMaxOrderByAggregateInput;
    _min?: RoleMinOrderByAggregateInput;
  };

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RoleScalarWhereWithAggregatesInput>;
    OR?: Enumerable<RoleScalarWhereWithAggregatesInput>;
    NOT?: Enumerable<RoleScalarWhereWithAggregatesInput>;
    roleId?: StringWithAggregatesFilter | string;
    userRole?: StringWithAggregatesFilter | string;
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null;
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null;
  };

  export type AddressWhereInput = {
    AND?: Enumerable<AddressWhereInput>;
    OR?: Enumerable<AddressWhereInput>;
    NOT?: Enumerable<AddressWhereInput>;
    addressId?: StringFilter | string;
    commune?: StringNullableFilter | string | null;
    address?: StringFilter | string;
    longitude?: StringFilter | string;
    latitude?: StringFilter | string;
    restauId?: StringNullableFilter | string | null;
    userId?: StringNullableFilter | string | null;
    User?: UserListRelationFilter;
    Restaurant?: RestaurantListRelationFilter;
    createdAt?: DateTimeNullableFilter | Date | string | null;
    updatedAt?: DateTimeNullableFilter | Date | string | null;
  };

  export type AddressOrderByWithRelationInput = {
    addressId?: SortOrder;
    commune?: SortOrder;
    address?: SortOrder;
    longitude?: SortOrder;
    latitude?: SortOrder;
    restauId?: SortOrder;
    userId?: SortOrder;
    User?: UserOrderByRelationAggregateInput;
    Restaurant?: RestaurantOrderByRelationAggregateInput;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AddressWhereUniqueInput = {
    addressId?: string;
  };

  export type AddressOrderByWithAggregationInput = {
    addressId?: SortOrder;
    commune?: SortOrder;
    address?: SortOrder;
    longitude?: SortOrder;
    latitude?: SortOrder;
    restauId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: AddressCountOrderByAggregateInput;
    _max?: AddressMaxOrderByAggregateInput;
    _min?: AddressMinOrderByAggregateInput;
  };

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AddressScalarWhereWithAggregatesInput>;
    OR?: Enumerable<AddressScalarWhereWithAggregatesInput>;
    NOT?: Enumerable<AddressScalarWhereWithAggregatesInput>;
    addressId?: StringWithAggregatesFilter | string;
    commune?: StringNullableWithAggregatesFilter | string | null;
    address?: StringWithAggregatesFilter | string;
    longitude?: StringWithAggregatesFilter | string;
    latitude?: StringWithAggregatesFilter | string;
    restauId?: StringNullableWithAggregatesFilter | string | null;
    userId?: StringNullableWithAggregatesFilter | string | null;
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null;
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null;
  };

  export type RestaurantWhereInput = {
    AND?: Enumerable<RestaurantWhereInput>;
    OR?: Enumerable<RestaurantWhereInput>;
    NOT?: Enumerable<RestaurantWhereInput>;
    restauId?: StringFilter | string;
    restauName?: StringFilter | string;
    restauDescription?: StringFilter | string;
    phoneNumber?: StringNullableFilter | string | null;
    email?: StringNullableFilter | string | null;
    RestauAddress?: XOR<AddressRelationFilter, AddressWhereInput> | null;
    RestauImages?: XOR<
      RestauImagesRelationFilter,
      RestauImagesWhereInput
    > | null;
    RestaurantUser?: RestauUserListRelationFilter;
    restauAddressId?: StringNullableFilter | string | null;
    mainImageId?: StringNullableFilter | string | null;
    isActive?: BoolFilter | boolean;
    createdAt?: DateTimeNullableFilter | Date | string | null;
    updatedAt?: DateTimeNullableFilter | Date | string | null;
  };

  export type RestaurantOrderByWithRelationInput = {
    restauId?: SortOrder;
    restauName?: SortOrder;
    restauDescription?: SortOrder;
    phoneNumber?: SortOrder;
    email?: SortOrder;
    RestauAddress?: AddressOrderByWithRelationInput;
    RestauImages?: RestauImagesOrderByWithRelationInput;
    RestaurantUser?: RestauUserOrderByRelationAggregateInput;
    restauAddressId?: SortOrder;
    mainImageId?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RestaurantWhereUniqueInput = {
    restauId?: string;
  };

  export type RestaurantOrderByWithAggregationInput = {
    restauId?: SortOrder;
    restauName?: SortOrder;
    restauDescription?: SortOrder;
    phoneNumber?: SortOrder;
    email?: SortOrder;
    restauAddressId?: SortOrder;
    mainImageId?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: RestaurantCountOrderByAggregateInput;
    _max?: RestaurantMaxOrderByAggregateInput;
    _min?: RestaurantMinOrderByAggregateInput;
  };

  export type RestaurantScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RestaurantScalarWhereWithAggregatesInput>;
    OR?: Enumerable<RestaurantScalarWhereWithAggregatesInput>;
    NOT?: Enumerable<RestaurantScalarWhereWithAggregatesInput>;
    restauId?: StringWithAggregatesFilter | string;
    restauName?: StringWithAggregatesFilter | string;
    restauDescription?: StringWithAggregatesFilter | string;
    phoneNumber?: StringNullableWithAggregatesFilter | string | null;
    email?: StringNullableWithAggregatesFilter | string | null;
    restauAddressId?: StringNullableWithAggregatesFilter | string | null;
    mainImageId?: StringNullableWithAggregatesFilter | string | null;
    isActive?: BoolWithAggregatesFilter | boolean;
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null;
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null;
  };

  export type RestauTokensWhereInput = {
    AND?: Enumerable<RestauTokensWhereInput>;
    OR?: Enumerable<RestauTokensWhereInput>;
    NOT?: Enumerable<RestauTokensWhereInput>;
    tokenId?: StringFilter | string;
    token?: StringFilter | string;
    RestauUser?: XOR<RestauUserRelationFilter, RestauUserWhereInput> | null;
    restauUserId?: StringFilter | string;
    createdAt?: DateTimeNullableFilter | Date | string | null;
    updatedAt?: DateTimeNullableFilter | Date | string | null;
  };

  export type RestauTokensOrderByWithRelationInput = {
    tokenId?: SortOrder;
    token?: SortOrder;
    RestauUser?: RestauUserOrderByWithRelationInput;
    restauUserId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RestauTokensWhereUniqueInput = {
    tokenId?: string;
  };

  export type RestauTokensOrderByWithAggregationInput = {
    tokenId?: SortOrder;
    token?: SortOrder;
    restauUserId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: RestauTokensCountOrderByAggregateInput;
    _max?: RestauTokensMaxOrderByAggregateInput;
    _min?: RestauTokensMinOrderByAggregateInput;
  };

  export type RestauTokensScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RestauTokensScalarWhereWithAggregatesInput>;
    OR?: Enumerable<RestauTokensScalarWhereWithAggregatesInput>;
    NOT?: Enumerable<RestauTokensScalarWhereWithAggregatesInput>;
    tokenId?: StringWithAggregatesFilter | string;
    token?: StringWithAggregatesFilter | string;
    restauUserId?: StringWithAggregatesFilter | string;
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null;
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null;
  };

  export type RestauUserWhereInput = {
    AND?: Enumerable<RestauUserWhereInput>;
    OR?: Enumerable<RestauUserWhereInput>;
    NOT?: Enumerable<RestauUserWhereInput>;
    restauUserId?: StringFilter | string;
    Token?: RestauTokensListRelationFilter;
    restauId?: StringFilter | string;
    userName?: StringFilter | string;
    phoneNumber?: StringFilter | string;
    completeName?: StringFilter | string;
    userImage?: StringFilter | string;
    password?: StringFilter | string;
    role?: EnumRestauRoleFilter | RestauRole;
    RestauImages?: XOR<
      RestauImagesRelationFilter,
      RestauImagesWhereInput
    > | null;
    Restaurant?: XOR<RestaurantRelationFilter, RestaurantWhereInput> | null;
    createdAt?: DateTimeNullableFilter | Date | string | null;
    updatedAt?: DateTimeNullableFilter | Date | string | null;
  };

  export type RestauUserOrderByWithRelationInput = {
    restauUserId?: SortOrder;
    Token?: RestauTokensOrderByRelationAggregateInput;
    restauId?: SortOrder;
    userName?: SortOrder;
    phoneNumber?: SortOrder;
    completeName?: SortOrder;
    userImage?: SortOrder;
    password?: SortOrder;
    role?: SortOrder;
    RestauImages?: RestauImagesOrderByWithRelationInput;
    Restaurant?: RestaurantOrderByWithRelationInput;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RestauUserWhereUniqueInput = {
    restauUserId?: string;
  };

  export type RestauUserOrderByWithAggregationInput = {
    restauUserId?: SortOrder;
    restauId?: SortOrder;
    userName?: SortOrder;
    phoneNumber?: SortOrder;
    completeName?: SortOrder;
    userImage?: SortOrder;
    password?: SortOrder;
    role?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: RestauUserCountOrderByAggregateInput;
    _max?: RestauUserMaxOrderByAggregateInput;
    _min?: RestauUserMinOrderByAggregateInput;
  };

  export type RestauUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RestauUserScalarWhereWithAggregatesInput>;
    OR?: Enumerable<RestauUserScalarWhereWithAggregatesInput>;
    NOT?: Enumerable<RestauUserScalarWhereWithAggregatesInput>;
    restauUserId?: StringWithAggregatesFilter | string;
    restauId?: StringWithAggregatesFilter | string;
    userName?: StringWithAggregatesFilter | string;
    phoneNumber?: StringWithAggregatesFilter | string;
    completeName?: StringWithAggregatesFilter | string;
    userImage?: StringWithAggregatesFilter | string;
    password?: StringWithAggregatesFilter | string;
    role?: EnumRestauRoleWithAggregatesFilter | RestauRole;
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null;
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null;
  };

  export type RestauImagesWhereInput = {
    AND?: Enumerable<RestauImagesWhereInput>;
    OR?: Enumerable<RestauImagesWhereInput>;
    NOT?: Enumerable<RestauImagesWhereInput>;
    imageId?: StringFilter | string;
    address?: StringFilter | string;
    publicUrl?: StringFilter | string;
    imageUrl?: StringFilter | string;
    restauId?: StringNullableFilter | string | null;
    Restaurant?: RestaurantListRelationFilter;
    RestauUser?: RestauUserListRelationFilter;
    createdAt?: DateTimeNullableFilter | Date | string | null;
    updatedAt?: DateTimeNullableFilter | Date | string | null;
  };

  export type RestauImagesOrderByWithRelationInput = {
    imageId?: SortOrder;
    address?: SortOrder;
    publicUrl?: SortOrder;
    imageUrl?: SortOrder;
    restauId?: SortOrder;
    Restaurant?: RestaurantOrderByRelationAggregateInput;
    RestauUser?: RestauUserOrderByRelationAggregateInput;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RestauImagesWhereUniqueInput = {
    imageId?: string;
  };

  export type RestauImagesOrderByWithAggregationInput = {
    imageId?: SortOrder;
    address?: SortOrder;
    publicUrl?: SortOrder;
    imageUrl?: SortOrder;
    restauId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: RestauImagesCountOrderByAggregateInput;
    _max?: RestauImagesMaxOrderByAggregateInput;
    _min?: RestauImagesMinOrderByAggregateInput;
  };

  export type RestauImagesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RestauImagesScalarWhereWithAggregatesInput>;
    OR?: Enumerable<RestauImagesScalarWhereWithAggregatesInput>;
    NOT?: Enumerable<RestauImagesScalarWhereWithAggregatesInput>;
    imageId?: StringWithAggregatesFilter | string;
    address?: StringWithAggregatesFilter | string;
    publicUrl?: StringWithAggregatesFilter | string;
    imageUrl?: StringWithAggregatesFilter | string;
    restauId?: StringNullableWithAggregatesFilter | string | null;
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null;
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null;
  };

  export type UserCreateInput = {
    userId?: string;
    phoneNumber: string;
    isPhoneConfirmed?: boolean;
    username: string;
    password: string;
    completeName?: string | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    Role: RoleCreateNestedOneWithoutUserInput;
    Token?: TokensCreateNestedManyWithoutUserInput;
    UserAddress?: AddressCreateNestedOneWithoutUserInput;
  };

  export type UserUncheckedCreateInput = {
    userId?: string;
    phoneNumber: string;
    isPhoneConfirmed?: boolean;
    username: string;
    password: string;
    completeName?: string | null;
    userRoleId: string;
    userAddressId?: string | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    Token?: TokensUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    isPhoneConfirmed?: BoolFieldUpdateOperationsInput | boolean;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    completeName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    Role?: RoleUpdateOneRequiredWithoutUserInput;
    Token?: TokensUpdateManyWithoutUserInput;
    UserAddress?: AddressUpdateOneWithoutUserInput;
  };

  export type UserUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    isPhoneConfirmed?: BoolFieldUpdateOperationsInput | boolean;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    completeName?: NullableStringFieldUpdateOperationsInput | string | null;
    userRoleId?: StringFieldUpdateOperationsInput | string;
    userAddressId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    Token?: TokensUncheckedUpdateManyWithoutUserInput;
  };

  export type UserCreateManyInput = {
    userId?: string;
    phoneNumber: string;
    isPhoneConfirmed?: boolean;
    username: string;
    password: string;
    completeName?: string | null;
    userRoleId: string;
    userAddressId?: string | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
  };

  export type UserUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    isPhoneConfirmed?: BoolFieldUpdateOperationsInput | boolean;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    completeName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type UserUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    isPhoneConfirmed?: BoolFieldUpdateOperationsInput | boolean;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    completeName?: NullableStringFieldUpdateOperationsInput | string | null;
    userRoleId?: StringFieldUpdateOperationsInput | string;
    userAddressId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type TokensCreateInput = {
    tokenId?: string;
    token: string;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    User: UserCreateNestedOneWithoutTokenInput;
  };

  export type TokensUncheckedCreateInput = {
    tokenId?: string;
    token: string;
    userId: string;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
  };

  export type TokensUpdateInput = {
    tokenId?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    User?: UserUpdateOneRequiredWithoutTokenInput;
  };

  export type TokensUncheckedUpdateInput = {
    tokenId?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type TokensCreateManyInput = {
    tokenId?: string;
    token: string;
    userId: string;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
  };

  export type TokensUpdateManyMutationInput = {
    tokenId?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type TokensUncheckedUpdateManyInput = {
    tokenId?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type RoleCreateInput = {
    roleId?: string;
    userRole: string;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    User?: UserCreateNestedManyWithoutRoleInput;
  };

  export type RoleUncheckedCreateInput = {
    roleId?: string;
    userRole: string;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    User?: UserUncheckedCreateNestedManyWithoutRoleInput;
  };

  export type RoleUpdateInput = {
    roleId?: StringFieldUpdateOperationsInput | string;
    userRole?: StringFieldUpdateOperationsInput | string;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    User?: UserUpdateManyWithoutRoleInput;
  };

  export type RoleUncheckedUpdateInput = {
    roleId?: StringFieldUpdateOperationsInput | string;
    userRole?: StringFieldUpdateOperationsInput | string;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    User?: UserUncheckedUpdateManyWithoutRoleInput;
  };

  export type RoleCreateManyInput = {
    roleId?: string;
    userRole: string;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
  };

  export type RoleUpdateManyMutationInput = {
    roleId?: StringFieldUpdateOperationsInput | string;
    userRole?: StringFieldUpdateOperationsInput | string;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type RoleUncheckedUpdateManyInput = {
    roleId?: StringFieldUpdateOperationsInput | string;
    userRole?: StringFieldUpdateOperationsInput | string;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type AddressCreateInput = {
    addressId?: string;
    commune?: string | null;
    address: string;
    longitude: string;
    latitude: string;
    restauId?: string | null;
    userId?: string | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    User?: UserCreateNestedManyWithoutUserAddressInput;
    Restaurant?: RestaurantCreateNestedManyWithoutRestauAddressInput;
  };

  export type AddressUncheckedCreateInput = {
    addressId?: string;
    commune?: string | null;
    address: string;
    longitude: string;
    latitude: string;
    restauId?: string | null;
    userId?: string | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    User?: UserUncheckedCreateNestedManyWithoutUserAddressInput;
    Restaurant?: RestaurantUncheckedCreateNestedManyWithoutRestauAddressInput;
  };

  export type AddressUpdateInput = {
    addressId?: StringFieldUpdateOperationsInput | string;
    commune?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: StringFieldUpdateOperationsInput | string;
    longitude?: StringFieldUpdateOperationsInput | string;
    latitude?: StringFieldUpdateOperationsInput | string;
    restauId?: NullableStringFieldUpdateOperationsInput | string | null;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    User?: UserUpdateManyWithoutUserAddressInput;
    Restaurant?: RestaurantUpdateManyWithoutRestauAddressInput;
  };

  export type AddressUncheckedUpdateInput = {
    addressId?: StringFieldUpdateOperationsInput | string;
    commune?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: StringFieldUpdateOperationsInput | string;
    longitude?: StringFieldUpdateOperationsInput | string;
    latitude?: StringFieldUpdateOperationsInput | string;
    restauId?: NullableStringFieldUpdateOperationsInput | string | null;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    User?: UserUncheckedUpdateManyWithoutUserAddressInput;
    Restaurant?: RestaurantUncheckedUpdateManyWithoutRestauAddressInput;
  };

  export type AddressCreateManyInput = {
    addressId?: string;
    commune?: string | null;
    address: string;
    longitude: string;
    latitude: string;
    restauId?: string | null;
    userId?: string | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
  };

  export type AddressUpdateManyMutationInput = {
    addressId?: StringFieldUpdateOperationsInput | string;
    commune?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: StringFieldUpdateOperationsInput | string;
    longitude?: StringFieldUpdateOperationsInput | string;
    latitude?: StringFieldUpdateOperationsInput | string;
    restauId?: NullableStringFieldUpdateOperationsInput | string | null;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type AddressUncheckedUpdateManyInput = {
    addressId?: StringFieldUpdateOperationsInput | string;
    commune?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: StringFieldUpdateOperationsInput | string;
    longitude?: StringFieldUpdateOperationsInput | string;
    latitude?: StringFieldUpdateOperationsInput | string;
    restauId?: NullableStringFieldUpdateOperationsInput | string | null;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type RestaurantCreateInput = {
    restauId?: string;
    restauName: string;
    restauDescription: string;
    phoneNumber?: string | null;
    email?: string | null;
    isActive?: boolean;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    RestauAddress?: AddressCreateNestedOneWithoutRestaurantInput;
    RestauImages?: RestauImagesCreateNestedOneWithoutRestaurantInput;
    RestaurantUser?: RestauUserCreateNestedManyWithoutRestaurantInput;
  };

  export type RestaurantUncheckedCreateInput = {
    restauId?: string;
    restauName: string;
    restauDescription: string;
    phoneNumber?: string | null;
    email?: string | null;
    restauAddressId?: string | null;
    mainImageId?: string | null;
    isActive?: boolean;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    RestaurantUser?: RestauUserUncheckedCreateNestedManyWithoutRestaurantInput;
  };

  export type RestaurantUpdateInput = {
    restauId?: StringFieldUpdateOperationsInput | string;
    restauName?: StringFieldUpdateOperationsInput | string;
    restauDescription?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    RestauAddress?: AddressUpdateOneWithoutRestaurantInput;
    RestauImages?: RestauImagesUpdateOneWithoutRestaurantInput;
    RestaurantUser?: RestauUserUpdateManyWithoutRestaurantInput;
  };

  export type RestaurantUncheckedUpdateInput = {
    restauId?: StringFieldUpdateOperationsInput | string;
    restauName?: StringFieldUpdateOperationsInput | string;
    restauDescription?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    restauAddressId?: NullableStringFieldUpdateOperationsInput | string | null;
    mainImageId?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    RestaurantUser?: RestauUserUncheckedUpdateManyWithoutRestaurantInput;
  };

  export type RestaurantCreateManyInput = {
    restauId?: string;
    restauName: string;
    restauDescription: string;
    phoneNumber?: string | null;
    email?: string | null;
    restauAddressId?: string | null;
    mainImageId?: string | null;
    isActive?: boolean;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
  };

  export type RestaurantUpdateManyMutationInput = {
    restauId?: StringFieldUpdateOperationsInput | string;
    restauName?: StringFieldUpdateOperationsInput | string;
    restauDescription?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type RestaurantUncheckedUpdateManyInput = {
    restauId?: StringFieldUpdateOperationsInput | string;
    restauName?: StringFieldUpdateOperationsInput | string;
    restauDescription?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    restauAddressId?: NullableStringFieldUpdateOperationsInput | string | null;
    mainImageId?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type RestauTokensCreateInput = {
    tokenId?: string;
    token: string;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    RestauUser?: RestauUserCreateNestedOneWithoutTokenInput;
  };

  export type RestauTokensUncheckedCreateInput = {
    tokenId?: string;
    token: string;
    restauUserId: string;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
  };

  export type RestauTokensUpdateInput = {
    tokenId?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    RestauUser?: RestauUserUpdateOneWithoutTokenInput;
  };

  export type RestauTokensUncheckedUpdateInput = {
    tokenId?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    restauUserId?: StringFieldUpdateOperationsInput | string;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type RestauTokensCreateManyInput = {
    tokenId?: string;
    token: string;
    restauUserId: string;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
  };

  export type RestauTokensUpdateManyMutationInput = {
    tokenId?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type RestauTokensUncheckedUpdateManyInput = {
    tokenId?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    restauUserId?: StringFieldUpdateOperationsInput | string;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type RestauUserCreateInput = {
    restauUserId?: string;
    userName: string;
    phoneNumber: string;
    completeName: string;
    password: string;
    role?: RestauRole;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    Token?: RestauTokensCreateNestedManyWithoutRestauUserInput;
    RestauImages?: RestauImagesCreateNestedOneWithoutRestauUserInput;
    Restaurant?: RestaurantCreateNestedOneWithoutRestaurantUserInput;
  };

  export type RestauUserUncheckedCreateInput = {
    restauUserId?: string;
    restauId: string;
    userName: string;
    phoneNumber: string;
    completeName: string;
    userImage: string;
    password: string;
    role?: RestauRole;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    Token?: RestauTokensUncheckedCreateNestedManyWithoutRestauUserInput;
  };

  export type RestauUserUpdateInput = {
    restauUserId?: StringFieldUpdateOperationsInput | string;
    userName?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    completeName?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    role?: EnumRestauRoleFieldUpdateOperationsInput | RestauRole;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    Token?: RestauTokensUpdateManyWithoutRestauUserInput;
    RestauImages?: RestauImagesUpdateOneWithoutRestauUserInput;
    Restaurant?: RestaurantUpdateOneWithoutRestaurantUserInput;
  };

  export type RestauUserUncheckedUpdateInput = {
    restauUserId?: StringFieldUpdateOperationsInput | string;
    restauId?: StringFieldUpdateOperationsInput | string;
    userName?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    completeName?: StringFieldUpdateOperationsInput | string;
    userImage?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    role?: EnumRestauRoleFieldUpdateOperationsInput | RestauRole;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    Token?: RestauTokensUncheckedUpdateManyWithoutRestauUserInput;
  };

  export type RestauUserCreateManyInput = {
    restauUserId?: string;
    restauId: string;
    userName: string;
    phoneNumber: string;
    completeName: string;
    userImage: string;
    password: string;
    role?: RestauRole;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
  };

  export type RestauUserUpdateManyMutationInput = {
    restauUserId?: StringFieldUpdateOperationsInput | string;
    userName?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    completeName?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    role?: EnumRestauRoleFieldUpdateOperationsInput | RestauRole;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type RestauUserUncheckedUpdateManyInput = {
    restauUserId?: StringFieldUpdateOperationsInput | string;
    restauId?: StringFieldUpdateOperationsInput | string;
    userName?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    completeName?: StringFieldUpdateOperationsInput | string;
    userImage?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    role?: EnumRestauRoleFieldUpdateOperationsInput | RestauRole;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type RestauImagesCreateInput = {
    imageId?: string;
    address: string;
    publicUrl: string;
    imageUrl: string;
    restauId?: string | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    Restaurant?: RestaurantCreateNestedManyWithoutRestauImagesInput;
    RestauUser?: RestauUserCreateNestedManyWithoutRestauImagesInput;
  };

  export type RestauImagesUncheckedCreateInput = {
    imageId?: string;
    address: string;
    publicUrl: string;
    imageUrl: string;
    restauId?: string | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    Restaurant?: RestaurantUncheckedCreateNestedManyWithoutRestauImagesInput;
    RestauUser?: RestauUserUncheckedCreateNestedManyWithoutRestauImagesInput;
  };

  export type RestauImagesUpdateInput = {
    imageId?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    publicUrl?: StringFieldUpdateOperationsInput | string;
    imageUrl?: StringFieldUpdateOperationsInput | string;
    restauId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    Restaurant?: RestaurantUpdateManyWithoutRestauImagesInput;
    RestauUser?: RestauUserUpdateManyWithoutRestauImagesInput;
  };

  export type RestauImagesUncheckedUpdateInput = {
    imageId?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    publicUrl?: StringFieldUpdateOperationsInput | string;
    imageUrl?: StringFieldUpdateOperationsInput | string;
    restauId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    Restaurant?: RestaurantUncheckedUpdateManyWithoutRestauImagesInput;
    RestauUser?: RestauUserUncheckedUpdateManyWithoutRestauImagesInput;
  };

  export type RestauImagesCreateManyInput = {
    imageId?: string;
    address: string;
    publicUrl: string;
    imageUrl: string;
    restauId?: string | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
  };

  export type RestauImagesUpdateManyMutationInput = {
    imageId?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    publicUrl?: StringFieldUpdateOperationsInput | string;
    imageUrl?: StringFieldUpdateOperationsInput | string;
    restauId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type RestauImagesUncheckedUpdateManyInput = {
    imageId?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    publicUrl?: StringFieldUpdateOperationsInput | string;
    imageUrl?: StringFieldUpdateOperationsInput | string;
    restauId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type StringFilter = {
    equals?: string;
    in?: Enumerable<string>;
    notIn?: Enumerable<string>;
    lt?: string;
    lte?: string;
    gt?: string;
    gte?: string;
    contains?: string;
    startsWith?: string;
    endsWith?: string;
    not?: NestedStringFilter | string;
  };

  export type BoolFilter = {
    equals?: boolean;
    not?: NestedBoolFilter | boolean;
  };

  export type StringNullableFilter = {
    equals?: string | null;
    in?: Enumerable<string> | null;
    notIn?: Enumerable<string> | null;
    lt?: string;
    lte?: string;
    gt?: string;
    gte?: string;
    contains?: string;
    startsWith?: string;
    endsWith?: string;
    not?: NestedStringNullableFilter | string | null;
  };

  export type RoleRelationFilter = {
    is?: RoleWhereInput;
    isNot?: RoleWhereInput;
  };

  export type TokensListRelationFilter = {
    every?: TokensWhereInput;
    some?: TokensWhereInput;
    none?: TokensWhereInput;
  };

  export type AddressRelationFilter = {
    is?: AddressWhereInput | null;
    isNot?: AddressWhereInput | null;
  };

  export type DateTimeNullableFilter = {
    equals?: Date | string | null;
    in?: Enumerable<Date> | Enumerable<string> | null;
    notIn?: Enumerable<Date> | Enumerable<string> | null;
    lt?: Date | string;
    lte?: Date | string;
    gt?: Date | string;
    gte?: Date | string;
    not?: NestedDateTimeNullableFilter | Date | string | null;
  };

  export type TokensOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserCountOrderByAggregateInput = {
    userId?: SortOrder;
    phoneNumber?: SortOrder;
    isPhoneConfirmed?: SortOrder;
    username?: SortOrder;
    password?: SortOrder;
    completeName?: SortOrder;
    userRoleId?: SortOrder;
    userAddressId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type UserMaxOrderByAggregateInput = {
    userId?: SortOrder;
    phoneNumber?: SortOrder;
    isPhoneConfirmed?: SortOrder;
    username?: SortOrder;
    password?: SortOrder;
    completeName?: SortOrder;
    userRoleId?: SortOrder;
    userAddressId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type UserMinOrderByAggregateInput = {
    userId?: SortOrder;
    phoneNumber?: SortOrder;
    isPhoneConfirmed?: SortOrder;
    username?: SortOrder;
    password?: SortOrder;
    completeName?: SortOrder;
    userRoleId?: SortOrder;
    userAddressId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type StringWithAggregatesFilter = {
    equals?: string;
    in?: Enumerable<string>;
    notIn?: Enumerable<string>;
    lt?: string;
    lte?: string;
    gt?: string;
    gte?: string;
    contains?: string;
    startsWith?: string;
    endsWith?: string;
    not?: NestedStringWithAggregatesFilter | string;
    _count?: NestedIntFilter;
    _min?: NestedStringFilter;
    _max?: NestedStringFilter;
  };

  export type BoolWithAggregatesFilter = {
    equals?: boolean;
    not?: NestedBoolWithAggregatesFilter | boolean;
    _count?: NestedIntFilter;
    _min?: NestedBoolFilter;
    _max?: NestedBoolFilter;
  };

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null;
    in?: Enumerable<string> | null;
    notIn?: Enumerable<string> | null;
    lt?: string;
    lte?: string;
    gt?: string;
    gte?: string;
    contains?: string;
    startsWith?: string;
    endsWith?: string;
    not?: NestedStringNullableWithAggregatesFilter | string | null;
    _count?: NestedIntNullableFilter;
    _min?: NestedStringNullableFilter;
    _max?: NestedStringNullableFilter;
  };

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null;
    in?: Enumerable<Date> | Enumerable<string> | null;
    notIn?: Enumerable<Date> | Enumerable<string> | null;
    lt?: Date | string;
    lte?: Date | string;
    gt?: Date | string;
    gte?: Date | string;
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null;
    _count?: NestedIntNullableFilter;
    _min?: NestedDateTimeNullableFilter;
    _max?: NestedDateTimeNullableFilter;
  };

  export type UserRelationFilter = {
    is?: UserWhereInput;
    isNot?: UserWhereInput;
  };

  export type TokensCountOrderByAggregateInput = {
    tokenId?: SortOrder;
    token?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type TokensMaxOrderByAggregateInput = {
    tokenId?: SortOrder;
    token?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type TokensMinOrderByAggregateInput = {
    tokenId?: SortOrder;
    token?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type UserListRelationFilter = {
    every?: UserWhereInput;
    some?: UserWhereInput;
    none?: UserWhereInput;
  };

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type RoleCountOrderByAggregateInput = {
    roleId?: SortOrder;
    userRole?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RoleMaxOrderByAggregateInput = {
    roleId?: SortOrder;
    userRole?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RoleMinOrderByAggregateInput = {
    roleId?: SortOrder;
    userRole?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RestaurantListRelationFilter = {
    every?: RestaurantWhereInput;
    some?: RestaurantWhereInput;
    none?: RestaurantWhereInput;
  };

  export type RestaurantOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type AddressCountOrderByAggregateInput = {
    addressId?: SortOrder;
    commune?: SortOrder;
    address?: SortOrder;
    longitude?: SortOrder;
    latitude?: SortOrder;
    restauId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AddressMaxOrderByAggregateInput = {
    addressId?: SortOrder;
    commune?: SortOrder;
    address?: SortOrder;
    longitude?: SortOrder;
    latitude?: SortOrder;
    restauId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AddressMinOrderByAggregateInput = {
    addressId?: SortOrder;
    commune?: SortOrder;
    address?: SortOrder;
    longitude?: SortOrder;
    latitude?: SortOrder;
    restauId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RestauImagesRelationFilter = {
    is?: RestauImagesWhereInput | null;
    isNot?: RestauImagesWhereInput | null;
  };

  export type RestauUserListRelationFilter = {
    every?: RestauUserWhereInput;
    some?: RestauUserWhereInput;
    none?: RestauUserWhereInput;
  };

  export type RestauUserOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type RestaurantCountOrderByAggregateInput = {
    restauId?: SortOrder;
    restauName?: SortOrder;
    restauDescription?: SortOrder;
    phoneNumber?: SortOrder;
    email?: SortOrder;
    restauAddressId?: SortOrder;
    mainImageId?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RestaurantMaxOrderByAggregateInput = {
    restauId?: SortOrder;
    restauName?: SortOrder;
    restauDescription?: SortOrder;
    phoneNumber?: SortOrder;
    email?: SortOrder;
    restauAddressId?: SortOrder;
    mainImageId?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RestaurantMinOrderByAggregateInput = {
    restauId?: SortOrder;
    restauName?: SortOrder;
    restauDescription?: SortOrder;
    phoneNumber?: SortOrder;
    email?: SortOrder;
    restauAddressId?: SortOrder;
    mainImageId?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RestauUserRelationFilter = {
    is?: RestauUserWhereInput | null;
    isNot?: RestauUserWhereInput | null;
  };

  export type RestauTokensCountOrderByAggregateInput = {
    tokenId?: SortOrder;
    token?: SortOrder;
    restauUserId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RestauTokensMaxOrderByAggregateInput = {
    tokenId?: SortOrder;
    token?: SortOrder;
    restauUserId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RestauTokensMinOrderByAggregateInput = {
    tokenId?: SortOrder;
    token?: SortOrder;
    restauUserId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RestauTokensListRelationFilter = {
    every?: RestauTokensWhereInput;
    some?: RestauTokensWhereInput;
    none?: RestauTokensWhereInput;
  };

  export type EnumRestauRoleFilter = {
    equals?: RestauRole;
    in?: Enumerable<RestauRole>;
    notIn?: Enumerable<RestauRole>;
    not?: NestedEnumRestauRoleFilter | RestauRole;
  };

  export type RestaurantRelationFilter = {
    is?: RestaurantWhereInput | null;
    isNot?: RestaurantWhereInput | null;
  };

  export type RestauTokensOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type RestauUserCountOrderByAggregateInput = {
    restauUserId?: SortOrder;
    restauId?: SortOrder;
    userName?: SortOrder;
    phoneNumber?: SortOrder;
    completeName?: SortOrder;
    userImage?: SortOrder;
    password?: SortOrder;
    role?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RestauUserMaxOrderByAggregateInput = {
    restauUserId?: SortOrder;
    restauId?: SortOrder;
    userName?: SortOrder;
    phoneNumber?: SortOrder;
    completeName?: SortOrder;
    userImage?: SortOrder;
    password?: SortOrder;
    role?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RestauUserMinOrderByAggregateInput = {
    restauUserId?: SortOrder;
    restauId?: SortOrder;
    userName?: SortOrder;
    phoneNumber?: SortOrder;
    completeName?: SortOrder;
    userImage?: SortOrder;
    password?: SortOrder;
    role?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type EnumRestauRoleWithAggregatesFilter = {
    equals?: RestauRole;
    in?: Enumerable<RestauRole>;
    notIn?: Enumerable<RestauRole>;
    not?: NestedEnumRestauRoleWithAggregatesFilter | RestauRole;
    _count?: NestedIntFilter;
    _min?: NestedEnumRestauRoleFilter;
    _max?: NestedEnumRestauRoleFilter;
  };

  export type RestauImagesCountOrderByAggregateInput = {
    imageId?: SortOrder;
    address?: SortOrder;
    publicUrl?: SortOrder;
    imageUrl?: SortOrder;
    restauId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RestauImagesMaxOrderByAggregateInput = {
    imageId?: SortOrder;
    address?: SortOrder;
    publicUrl?: SortOrder;
    imageUrl?: SortOrder;
    restauId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RestauImagesMinOrderByAggregateInput = {
    imageId?: SortOrder;
    address?: SortOrder;
    publicUrl?: SortOrder;
    imageUrl?: SortOrder;
    restauId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RoleCreateNestedOneWithoutUserInput = {
    create?: XOR<
      RoleCreateWithoutUserInput,
      RoleUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: RoleCreateOrConnectWithoutUserInput;
    connect?: RoleWhereUniqueInput;
  };

  export type TokensCreateNestedManyWithoutUserInput = {
    create?: XOR<
      Enumerable<TokensCreateWithoutUserInput>,
      Enumerable<TokensUncheckedCreateWithoutUserInput>
    >;
    connectOrCreate?: Enumerable<TokensCreateOrConnectWithoutUserInput>;
    createMany?: TokensCreateManyUserInputEnvelope;
    connect?: Enumerable<TokensWhereUniqueInput>;
  };

  export type AddressCreateNestedOneWithoutUserInput = {
    create?: XOR<
      AddressCreateWithoutUserInput,
      AddressUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput;
    connect?: AddressWhereUniqueInput;
  };

  export type TokensUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<
      Enumerable<TokensCreateWithoutUserInput>,
      Enumerable<TokensUncheckedCreateWithoutUserInput>
    >;
    connectOrCreate?: Enumerable<TokensCreateOrConnectWithoutUserInput>;
    createMany?: TokensCreateManyUserInputEnvelope;
    connect?: Enumerable<TokensWhereUniqueInput>;
  };

  export type StringFieldUpdateOperationsInput = {
    set?: string;
  };

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean;
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
  };

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
  };

  export type RoleUpdateOneRequiredWithoutUserInput = {
    create?: XOR<
      RoleCreateWithoutUserInput,
      RoleUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: RoleCreateOrConnectWithoutUserInput;
    upsert?: RoleUpsertWithoutUserInput;
    connect?: RoleWhereUniqueInput;
    update?: XOR<
      RoleUpdateWithoutUserInput,
      RoleUncheckedUpdateWithoutUserInput
    >;
  };

  export type TokensUpdateManyWithoutUserInput = {
    create?: XOR<
      Enumerable<TokensCreateWithoutUserInput>,
      Enumerable<TokensUncheckedCreateWithoutUserInput>
    >;
    connectOrCreate?: Enumerable<TokensCreateOrConnectWithoutUserInput>;
    upsert?: Enumerable<TokensUpsertWithWhereUniqueWithoutUserInput>;
    createMany?: TokensCreateManyUserInputEnvelope;
    set?: Enumerable<TokensWhereUniqueInput>;
    disconnect?: Enumerable<TokensWhereUniqueInput>;
    delete?: Enumerable<TokensWhereUniqueInput>;
    connect?: Enumerable<TokensWhereUniqueInput>;
    update?: Enumerable<TokensUpdateWithWhereUniqueWithoutUserInput>;
    updateMany?: Enumerable<TokensUpdateManyWithWhereWithoutUserInput>;
    deleteMany?: Enumerable<TokensScalarWhereInput>;
  };

  export type AddressUpdateOneWithoutUserInput = {
    create?: XOR<
      AddressCreateWithoutUserInput,
      AddressUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput;
    upsert?: AddressUpsertWithoutUserInput;
    disconnect?: boolean;
    delete?: boolean;
    connect?: AddressWhereUniqueInput;
    update?: XOR<
      AddressUpdateWithoutUserInput,
      AddressUncheckedUpdateWithoutUserInput
    >;
  };

  export type TokensUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<
      Enumerable<TokensCreateWithoutUserInput>,
      Enumerable<TokensUncheckedCreateWithoutUserInput>
    >;
    connectOrCreate?: Enumerable<TokensCreateOrConnectWithoutUserInput>;
    upsert?: Enumerable<TokensUpsertWithWhereUniqueWithoutUserInput>;
    createMany?: TokensCreateManyUserInputEnvelope;
    set?: Enumerable<TokensWhereUniqueInput>;
    disconnect?: Enumerable<TokensWhereUniqueInput>;
    delete?: Enumerable<TokensWhereUniqueInput>;
    connect?: Enumerable<TokensWhereUniqueInput>;
    update?: Enumerable<TokensUpdateWithWhereUniqueWithoutUserInput>;
    updateMany?: Enumerable<TokensUpdateManyWithWhereWithoutUserInput>;
    deleteMany?: Enumerable<TokensScalarWhereInput>;
  };

  export type UserCreateNestedOneWithoutTokenInput = {
    create?: XOR<
      UserCreateWithoutTokenInput,
      UserUncheckedCreateWithoutTokenInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutTokenInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutTokenInput = {
    create?: XOR<
      UserCreateWithoutTokenInput,
      UserUncheckedCreateWithoutTokenInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutTokenInput;
    upsert?: UserUpsertWithoutTokenInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      UserUpdateWithoutTokenInput,
      UserUncheckedUpdateWithoutTokenInput
    >;
  };

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<
      Enumerable<UserCreateWithoutRoleInput>,
      Enumerable<UserUncheckedCreateWithoutRoleInput>
    >;
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRoleInput>;
    createMany?: UserCreateManyRoleInputEnvelope;
    connect?: Enumerable<UserWhereUniqueInput>;
  };

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<
      Enumerable<UserCreateWithoutRoleInput>,
      Enumerable<UserUncheckedCreateWithoutRoleInput>
    >;
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRoleInput>;
    createMany?: UserCreateManyRoleInputEnvelope;
    connect?: Enumerable<UserWhereUniqueInput>;
  };

  export type UserUpdateManyWithoutRoleInput = {
    create?: XOR<
      Enumerable<UserCreateWithoutRoleInput>,
      Enumerable<UserUncheckedCreateWithoutRoleInput>
    >;
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRoleInput>;
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutRoleInput>;
    createMany?: UserCreateManyRoleInputEnvelope;
    set?: Enumerable<UserWhereUniqueInput>;
    disconnect?: Enumerable<UserWhereUniqueInput>;
    delete?: Enumerable<UserWhereUniqueInput>;
    connect?: Enumerable<UserWhereUniqueInput>;
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutRoleInput>;
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutRoleInput>;
    deleteMany?: Enumerable<UserScalarWhereInput>;
  };

  export type UserUncheckedUpdateManyWithoutRoleInput = {
    create?: XOR<
      Enumerable<UserCreateWithoutRoleInput>,
      Enumerable<UserUncheckedCreateWithoutRoleInput>
    >;
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRoleInput>;
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutRoleInput>;
    createMany?: UserCreateManyRoleInputEnvelope;
    set?: Enumerable<UserWhereUniqueInput>;
    disconnect?: Enumerable<UserWhereUniqueInput>;
    delete?: Enumerable<UserWhereUniqueInput>;
    connect?: Enumerable<UserWhereUniqueInput>;
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutRoleInput>;
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutRoleInput>;
    deleteMany?: Enumerable<UserScalarWhereInput>;
  };

  export type UserCreateNestedManyWithoutUserAddressInput = {
    create?: XOR<
      Enumerable<UserCreateWithoutUserAddressInput>,
      Enumerable<UserUncheckedCreateWithoutUserAddressInput>
    >;
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutUserAddressInput>;
    createMany?: UserCreateManyUserAddressInputEnvelope;
    connect?: Enumerable<UserWhereUniqueInput>;
  };

  export type RestaurantCreateNestedManyWithoutRestauAddressInput = {
    create?: XOR<
      Enumerable<RestaurantCreateWithoutRestauAddressInput>,
      Enumerable<RestaurantUncheckedCreateWithoutRestauAddressInput>
    >;
    connectOrCreate?: Enumerable<RestaurantCreateOrConnectWithoutRestauAddressInput>;
    createMany?: RestaurantCreateManyRestauAddressInputEnvelope;
    connect?: Enumerable<RestaurantWhereUniqueInput>;
  };

  export type UserUncheckedCreateNestedManyWithoutUserAddressInput = {
    create?: XOR<
      Enumerable<UserCreateWithoutUserAddressInput>,
      Enumerable<UserUncheckedCreateWithoutUserAddressInput>
    >;
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutUserAddressInput>;
    createMany?: UserCreateManyUserAddressInputEnvelope;
    connect?: Enumerable<UserWhereUniqueInput>;
  };

  export type RestaurantUncheckedCreateNestedManyWithoutRestauAddressInput = {
    create?: XOR<
      Enumerable<RestaurantCreateWithoutRestauAddressInput>,
      Enumerable<RestaurantUncheckedCreateWithoutRestauAddressInput>
    >;
    connectOrCreate?: Enumerable<RestaurantCreateOrConnectWithoutRestauAddressInput>;
    createMany?: RestaurantCreateManyRestauAddressInputEnvelope;
    connect?: Enumerable<RestaurantWhereUniqueInput>;
  };

  export type UserUpdateManyWithoutUserAddressInput = {
    create?: XOR<
      Enumerable<UserCreateWithoutUserAddressInput>,
      Enumerable<UserUncheckedCreateWithoutUserAddressInput>
    >;
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutUserAddressInput>;
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutUserAddressInput>;
    createMany?: UserCreateManyUserAddressInputEnvelope;
    set?: Enumerable<UserWhereUniqueInput>;
    disconnect?: Enumerable<UserWhereUniqueInput>;
    delete?: Enumerable<UserWhereUniqueInput>;
    connect?: Enumerable<UserWhereUniqueInput>;
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutUserAddressInput>;
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutUserAddressInput>;
    deleteMany?: Enumerable<UserScalarWhereInput>;
  };

  export type RestaurantUpdateManyWithoutRestauAddressInput = {
    create?: XOR<
      Enumerable<RestaurantCreateWithoutRestauAddressInput>,
      Enumerable<RestaurantUncheckedCreateWithoutRestauAddressInput>
    >;
    connectOrCreate?: Enumerable<RestaurantCreateOrConnectWithoutRestauAddressInput>;
    upsert?: Enumerable<RestaurantUpsertWithWhereUniqueWithoutRestauAddressInput>;
    createMany?: RestaurantCreateManyRestauAddressInputEnvelope;
    set?: Enumerable<RestaurantWhereUniqueInput>;
    disconnect?: Enumerable<RestaurantWhereUniqueInput>;
    delete?: Enumerable<RestaurantWhereUniqueInput>;
    connect?: Enumerable<RestaurantWhereUniqueInput>;
    update?: Enumerable<RestaurantUpdateWithWhereUniqueWithoutRestauAddressInput>;
    updateMany?: Enumerable<RestaurantUpdateManyWithWhereWithoutRestauAddressInput>;
    deleteMany?: Enumerable<RestaurantScalarWhereInput>;
  };

  export type UserUncheckedUpdateManyWithoutUserAddressInput = {
    create?: XOR<
      Enumerable<UserCreateWithoutUserAddressInput>,
      Enumerable<UserUncheckedCreateWithoutUserAddressInput>
    >;
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutUserAddressInput>;
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutUserAddressInput>;
    createMany?: UserCreateManyUserAddressInputEnvelope;
    set?: Enumerable<UserWhereUniqueInput>;
    disconnect?: Enumerable<UserWhereUniqueInput>;
    delete?: Enumerable<UserWhereUniqueInput>;
    connect?: Enumerable<UserWhereUniqueInput>;
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutUserAddressInput>;
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutUserAddressInput>;
    deleteMany?: Enumerable<UserScalarWhereInput>;
  };

  export type RestaurantUncheckedUpdateManyWithoutRestauAddressInput = {
    create?: XOR<
      Enumerable<RestaurantCreateWithoutRestauAddressInput>,
      Enumerable<RestaurantUncheckedCreateWithoutRestauAddressInput>
    >;
    connectOrCreate?: Enumerable<RestaurantCreateOrConnectWithoutRestauAddressInput>;
    upsert?: Enumerable<RestaurantUpsertWithWhereUniqueWithoutRestauAddressInput>;
    createMany?: RestaurantCreateManyRestauAddressInputEnvelope;
    set?: Enumerable<RestaurantWhereUniqueInput>;
    disconnect?: Enumerable<RestaurantWhereUniqueInput>;
    delete?: Enumerable<RestaurantWhereUniqueInput>;
    connect?: Enumerable<RestaurantWhereUniqueInput>;
    update?: Enumerable<RestaurantUpdateWithWhereUniqueWithoutRestauAddressInput>;
    updateMany?: Enumerable<RestaurantUpdateManyWithWhereWithoutRestauAddressInput>;
    deleteMany?: Enumerable<RestaurantScalarWhereInput>;
  };

  export type AddressCreateNestedOneWithoutRestaurantInput = {
    create?: XOR<
      AddressCreateWithoutRestaurantInput,
      AddressUncheckedCreateWithoutRestaurantInput
    >;
    connectOrCreate?: AddressCreateOrConnectWithoutRestaurantInput;
    connect?: AddressWhereUniqueInput;
  };

  export type RestauImagesCreateNestedOneWithoutRestaurantInput = {
    create?: XOR<
      RestauImagesCreateWithoutRestaurantInput,
      RestauImagesUncheckedCreateWithoutRestaurantInput
    >;
    connectOrCreate?: RestauImagesCreateOrConnectWithoutRestaurantInput;
    connect?: RestauImagesWhereUniqueInput;
  };

  export type RestauUserCreateNestedManyWithoutRestaurantInput = {
    create?: XOR<
      Enumerable<RestauUserCreateWithoutRestaurantInput>,
      Enumerable<RestauUserUncheckedCreateWithoutRestaurantInput>
    >;
    connectOrCreate?: Enumerable<RestauUserCreateOrConnectWithoutRestaurantInput>;
    createMany?: RestauUserCreateManyRestaurantInputEnvelope;
    connect?: Enumerable<RestauUserWhereUniqueInput>;
  };

  export type RestauUserUncheckedCreateNestedManyWithoutRestaurantInput = {
    create?: XOR<
      Enumerable<RestauUserCreateWithoutRestaurantInput>,
      Enumerable<RestauUserUncheckedCreateWithoutRestaurantInput>
    >;
    connectOrCreate?: Enumerable<RestauUserCreateOrConnectWithoutRestaurantInput>;
    createMany?: RestauUserCreateManyRestaurantInputEnvelope;
    connect?: Enumerable<RestauUserWhereUniqueInput>;
  };

  export type AddressUpdateOneWithoutRestaurantInput = {
    create?: XOR<
      AddressCreateWithoutRestaurantInput,
      AddressUncheckedCreateWithoutRestaurantInput
    >;
    connectOrCreate?: AddressCreateOrConnectWithoutRestaurantInput;
    upsert?: AddressUpsertWithoutRestaurantInput;
    disconnect?: boolean;
    delete?: boolean;
    connect?: AddressWhereUniqueInput;
    update?: XOR<
      AddressUpdateWithoutRestaurantInput,
      AddressUncheckedUpdateWithoutRestaurantInput
    >;
  };

  export type RestauImagesUpdateOneWithoutRestaurantInput = {
    create?: XOR<
      RestauImagesCreateWithoutRestaurantInput,
      RestauImagesUncheckedCreateWithoutRestaurantInput
    >;
    connectOrCreate?: RestauImagesCreateOrConnectWithoutRestaurantInput;
    upsert?: RestauImagesUpsertWithoutRestaurantInput;
    disconnect?: boolean;
    delete?: boolean;
    connect?: RestauImagesWhereUniqueInput;
    update?: XOR<
      RestauImagesUpdateWithoutRestaurantInput,
      RestauImagesUncheckedUpdateWithoutRestaurantInput
    >;
  };

  export type RestauUserUpdateManyWithoutRestaurantInput = {
    create?: XOR<
      Enumerable<RestauUserCreateWithoutRestaurantInput>,
      Enumerable<RestauUserUncheckedCreateWithoutRestaurantInput>
    >;
    connectOrCreate?: Enumerable<RestauUserCreateOrConnectWithoutRestaurantInput>;
    upsert?: Enumerable<RestauUserUpsertWithWhereUniqueWithoutRestaurantInput>;
    createMany?: RestauUserCreateManyRestaurantInputEnvelope;
    set?: Enumerable<RestauUserWhereUniqueInput>;
    disconnect?: Enumerable<RestauUserWhereUniqueInput>;
    delete?: Enumerable<RestauUserWhereUniqueInput>;
    connect?: Enumerable<RestauUserWhereUniqueInput>;
    update?: Enumerable<RestauUserUpdateWithWhereUniqueWithoutRestaurantInput>;
    updateMany?: Enumerable<RestauUserUpdateManyWithWhereWithoutRestaurantInput>;
    deleteMany?: Enumerable<RestauUserScalarWhereInput>;
  };

  export type RestauUserUncheckedUpdateManyWithoutRestaurantInput = {
    create?: XOR<
      Enumerable<RestauUserCreateWithoutRestaurantInput>,
      Enumerable<RestauUserUncheckedCreateWithoutRestaurantInput>
    >;
    connectOrCreate?: Enumerable<RestauUserCreateOrConnectWithoutRestaurantInput>;
    upsert?: Enumerable<RestauUserUpsertWithWhereUniqueWithoutRestaurantInput>;
    createMany?: RestauUserCreateManyRestaurantInputEnvelope;
    set?: Enumerable<RestauUserWhereUniqueInput>;
    disconnect?: Enumerable<RestauUserWhereUniqueInput>;
    delete?: Enumerable<RestauUserWhereUniqueInput>;
    connect?: Enumerable<RestauUserWhereUniqueInput>;
    update?: Enumerable<RestauUserUpdateWithWhereUniqueWithoutRestaurantInput>;
    updateMany?: Enumerable<RestauUserUpdateManyWithWhereWithoutRestaurantInput>;
    deleteMany?: Enumerable<RestauUserScalarWhereInput>;
  };

  export type RestauUserCreateNestedOneWithoutTokenInput = {
    create?: XOR<
      RestauUserCreateWithoutTokenInput,
      RestauUserUncheckedCreateWithoutTokenInput
    >;
    connectOrCreate?: RestauUserCreateOrConnectWithoutTokenInput;
    connect?: RestauUserWhereUniqueInput;
  };

  export type RestauUserUpdateOneWithoutTokenInput = {
    create?: XOR<
      RestauUserCreateWithoutTokenInput,
      RestauUserUncheckedCreateWithoutTokenInput
    >;
    connectOrCreate?: RestauUserCreateOrConnectWithoutTokenInput;
    upsert?: RestauUserUpsertWithoutTokenInput;
    disconnect?: boolean;
    delete?: boolean;
    connect?: RestauUserWhereUniqueInput;
    update?: XOR<
      RestauUserUpdateWithoutTokenInput,
      RestauUserUncheckedUpdateWithoutTokenInput
    >;
  };

  export type RestauTokensCreateNestedManyWithoutRestauUserInput = {
    create?: XOR<
      Enumerable<RestauTokensCreateWithoutRestauUserInput>,
      Enumerable<RestauTokensUncheckedCreateWithoutRestauUserInput>
    >;
    connectOrCreate?: Enumerable<RestauTokensCreateOrConnectWithoutRestauUserInput>;
    createMany?: RestauTokensCreateManyRestauUserInputEnvelope;
    connect?: Enumerable<RestauTokensWhereUniqueInput>;
  };

  export type RestauImagesCreateNestedOneWithoutRestauUserInput = {
    create?: XOR<
      RestauImagesCreateWithoutRestauUserInput,
      RestauImagesUncheckedCreateWithoutRestauUserInput
    >;
    connectOrCreate?: RestauImagesCreateOrConnectWithoutRestauUserInput;
    connect?: RestauImagesWhereUniqueInput;
  };

  export type RestaurantCreateNestedOneWithoutRestaurantUserInput = {
    create?: XOR<
      RestaurantCreateWithoutRestaurantUserInput,
      RestaurantUncheckedCreateWithoutRestaurantUserInput
    >;
    connectOrCreate?: RestaurantCreateOrConnectWithoutRestaurantUserInput;
    connect?: RestaurantWhereUniqueInput;
  };

  export type RestauTokensUncheckedCreateNestedManyWithoutRestauUserInput = {
    create?: XOR<
      Enumerable<RestauTokensCreateWithoutRestauUserInput>,
      Enumerable<RestauTokensUncheckedCreateWithoutRestauUserInput>
    >;
    connectOrCreate?: Enumerable<RestauTokensCreateOrConnectWithoutRestauUserInput>;
    createMany?: RestauTokensCreateManyRestauUserInputEnvelope;
    connect?: Enumerable<RestauTokensWhereUniqueInput>;
  };

  export type EnumRestauRoleFieldUpdateOperationsInput = {
    set?: RestauRole;
  };

  export type RestauTokensUpdateManyWithoutRestauUserInput = {
    create?: XOR<
      Enumerable<RestauTokensCreateWithoutRestauUserInput>,
      Enumerable<RestauTokensUncheckedCreateWithoutRestauUserInput>
    >;
    connectOrCreate?: Enumerable<RestauTokensCreateOrConnectWithoutRestauUserInput>;
    upsert?: Enumerable<RestauTokensUpsertWithWhereUniqueWithoutRestauUserInput>;
    createMany?: RestauTokensCreateManyRestauUserInputEnvelope;
    set?: Enumerable<RestauTokensWhereUniqueInput>;
    disconnect?: Enumerable<RestauTokensWhereUniqueInput>;
    delete?: Enumerable<RestauTokensWhereUniqueInput>;
    connect?: Enumerable<RestauTokensWhereUniqueInput>;
    update?: Enumerable<RestauTokensUpdateWithWhereUniqueWithoutRestauUserInput>;
    updateMany?: Enumerable<RestauTokensUpdateManyWithWhereWithoutRestauUserInput>;
    deleteMany?: Enumerable<RestauTokensScalarWhereInput>;
  };

  export type RestauImagesUpdateOneWithoutRestauUserInput = {
    create?: XOR<
      RestauImagesCreateWithoutRestauUserInput,
      RestauImagesUncheckedCreateWithoutRestauUserInput
    >;
    connectOrCreate?: RestauImagesCreateOrConnectWithoutRestauUserInput;
    upsert?: RestauImagesUpsertWithoutRestauUserInput;
    disconnect?: boolean;
    delete?: boolean;
    connect?: RestauImagesWhereUniqueInput;
    update?: XOR<
      RestauImagesUpdateWithoutRestauUserInput,
      RestauImagesUncheckedUpdateWithoutRestauUserInput
    >;
  };

  export type RestaurantUpdateOneWithoutRestaurantUserInput = {
    create?: XOR<
      RestaurantCreateWithoutRestaurantUserInput,
      RestaurantUncheckedCreateWithoutRestaurantUserInput
    >;
    connectOrCreate?: RestaurantCreateOrConnectWithoutRestaurantUserInput;
    upsert?: RestaurantUpsertWithoutRestaurantUserInput;
    disconnect?: boolean;
    delete?: boolean;
    connect?: RestaurantWhereUniqueInput;
    update?: XOR<
      RestaurantUpdateWithoutRestaurantUserInput,
      RestaurantUncheckedUpdateWithoutRestaurantUserInput
    >;
  };

  export type RestauTokensUncheckedUpdateManyWithoutRestauUserInput = {
    create?: XOR<
      Enumerable<RestauTokensCreateWithoutRestauUserInput>,
      Enumerable<RestauTokensUncheckedCreateWithoutRestauUserInput>
    >;
    connectOrCreate?: Enumerable<RestauTokensCreateOrConnectWithoutRestauUserInput>;
    upsert?: Enumerable<RestauTokensUpsertWithWhereUniqueWithoutRestauUserInput>;
    createMany?: RestauTokensCreateManyRestauUserInputEnvelope;
    set?: Enumerable<RestauTokensWhereUniqueInput>;
    disconnect?: Enumerable<RestauTokensWhereUniqueInput>;
    delete?: Enumerable<RestauTokensWhereUniqueInput>;
    connect?: Enumerable<RestauTokensWhereUniqueInput>;
    update?: Enumerable<RestauTokensUpdateWithWhereUniqueWithoutRestauUserInput>;
    updateMany?: Enumerable<RestauTokensUpdateManyWithWhereWithoutRestauUserInput>;
    deleteMany?: Enumerable<RestauTokensScalarWhereInput>;
  };

  export type RestaurantCreateNestedManyWithoutRestauImagesInput = {
    create?: XOR<
      Enumerable<RestaurantCreateWithoutRestauImagesInput>,
      Enumerable<RestaurantUncheckedCreateWithoutRestauImagesInput>
    >;
    connectOrCreate?: Enumerable<RestaurantCreateOrConnectWithoutRestauImagesInput>;
    createMany?: RestaurantCreateManyRestauImagesInputEnvelope;
    connect?: Enumerable<RestaurantWhereUniqueInput>;
  };

  export type RestauUserCreateNestedManyWithoutRestauImagesInput = {
    create?: XOR<
      Enumerable<RestauUserCreateWithoutRestauImagesInput>,
      Enumerable<RestauUserUncheckedCreateWithoutRestauImagesInput>
    >;
    connectOrCreate?: Enumerable<RestauUserCreateOrConnectWithoutRestauImagesInput>;
    createMany?: RestauUserCreateManyRestauImagesInputEnvelope;
    connect?: Enumerable<RestauUserWhereUniqueInput>;
  };

  export type RestaurantUncheckedCreateNestedManyWithoutRestauImagesInput = {
    create?: XOR<
      Enumerable<RestaurantCreateWithoutRestauImagesInput>,
      Enumerable<RestaurantUncheckedCreateWithoutRestauImagesInput>
    >;
    connectOrCreate?: Enumerable<RestaurantCreateOrConnectWithoutRestauImagesInput>;
    createMany?: RestaurantCreateManyRestauImagesInputEnvelope;
    connect?: Enumerable<RestaurantWhereUniqueInput>;
  };

  export type RestauUserUncheckedCreateNestedManyWithoutRestauImagesInput = {
    create?: XOR<
      Enumerable<RestauUserCreateWithoutRestauImagesInput>,
      Enumerable<RestauUserUncheckedCreateWithoutRestauImagesInput>
    >;
    connectOrCreate?: Enumerable<RestauUserCreateOrConnectWithoutRestauImagesInput>;
    createMany?: RestauUserCreateManyRestauImagesInputEnvelope;
    connect?: Enumerable<RestauUserWhereUniqueInput>;
  };

  export type RestaurantUpdateManyWithoutRestauImagesInput = {
    create?: XOR<
      Enumerable<RestaurantCreateWithoutRestauImagesInput>,
      Enumerable<RestaurantUncheckedCreateWithoutRestauImagesInput>
    >;
    connectOrCreate?: Enumerable<RestaurantCreateOrConnectWithoutRestauImagesInput>;
    upsert?: Enumerable<RestaurantUpsertWithWhereUniqueWithoutRestauImagesInput>;
    createMany?: RestaurantCreateManyRestauImagesInputEnvelope;
    set?: Enumerable<RestaurantWhereUniqueInput>;
    disconnect?: Enumerable<RestaurantWhereUniqueInput>;
    delete?: Enumerable<RestaurantWhereUniqueInput>;
    connect?: Enumerable<RestaurantWhereUniqueInput>;
    update?: Enumerable<RestaurantUpdateWithWhereUniqueWithoutRestauImagesInput>;
    updateMany?: Enumerable<RestaurantUpdateManyWithWhereWithoutRestauImagesInput>;
    deleteMany?: Enumerable<RestaurantScalarWhereInput>;
  };

  export type RestauUserUpdateManyWithoutRestauImagesInput = {
    create?: XOR<
      Enumerable<RestauUserCreateWithoutRestauImagesInput>,
      Enumerable<RestauUserUncheckedCreateWithoutRestauImagesInput>
    >;
    connectOrCreate?: Enumerable<RestauUserCreateOrConnectWithoutRestauImagesInput>;
    upsert?: Enumerable<RestauUserUpsertWithWhereUniqueWithoutRestauImagesInput>;
    createMany?: RestauUserCreateManyRestauImagesInputEnvelope;
    set?: Enumerable<RestauUserWhereUniqueInput>;
    disconnect?: Enumerable<RestauUserWhereUniqueInput>;
    delete?: Enumerable<RestauUserWhereUniqueInput>;
    connect?: Enumerable<RestauUserWhereUniqueInput>;
    update?: Enumerable<RestauUserUpdateWithWhereUniqueWithoutRestauImagesInput>;
    updateMany?: Enumerable<RestauUserUpdateManyWithWhereWithoutRestauImagesInput>;
    deleteMany?: Enumerable<RestauUserScalarWhereInput>;
  };

  export type RestaurantUncheckedUpdateManyWithoutRestauImagesInput = {
    create?: XOR<
      Enumerable<RestaurantCreateWithoutRestauImagesInput>,
      Enumerable<RestaurantUncheckedCreateWithoutRestauImagesInput>
    >;
    connectOrCreate?: Enumerable<RestaurantCreateOrConnectWithoutRestauImagesInput>;
    upsert?: Enumerable<RestaurantUpsertWithWhereUniqueWithoutRestauImagesInput>;
    createMany?: RestaurantCreateManyRestauImagesInputEnvelope;
    set?: Enumerable<RestaurantWhereUniqueInput>;
    disconnect?: Enumerable<RestaurantWhereUniqueInput>;
    delete?: Enumerable<RestaurantWhereUniqueInput>;
    connect?: Enumerable<RestaurantWhereUniqueInput>;
    update?: Enumerable<RestaurantUpdateWithWhereUniqueWithoutRestauImagesInput>;
    updateMany?: Enumerable<RestaurantUpdateManyWithWhereWithoutRestauImagesInput>;
    deleteMany?: Enumerable<RestaurantScalarWhereInput>;
  };

  export type RestauUserUncheckedUpdateManyWithoutRestauImagesInput = {
    create?: XOR<
      Enumerable<RestauUserCreateWithoutRestauImagesInput>,
      Enumerable<RestauUserUncheckedCreateWithoutRestauImagesInput>
    >;
    connectOrCreate?: Enumerable<RestauUserCreateOrConnectWithoutRestauImagesInput>;
    upsert?: Enumerable<RestauUserUpsertWithWhereUniqueWithoutRestauImagesInput>;
    createMany?: RestauUserCreateManyRestauImagesInputEnvelope;
    set?: Enumerable<RestauUserWhereUniqueInput>;
    disconnect?: Enumerable<RestauUserWhereUniqueInput>;
    delete?: Enumerable<RestauUserWhereUniqueInput>;
    connect?: Enumerable<RestauUserWhereUniqueInput>;
    update?: Enumerable<RestauUserUpdateWithWhereUniqueWithoutRestauImagesInput>;
    updateMany?: Enumerable<RestauUserUpdateManyWithWhereWithoutRestauImagesInput>;
    deleteMany?: Enumerable<RestauUserScalarWhereInput>;
  };

  export type NestedStringFilter = {
    equals?: string;
    in?: Enumerable<string>;
    notIn?: Enumerable<string>;
    lt?: string;
    lte?: string;
    gt?: string;
    gte?: string;
    contains?: string;
    startsWith?: string;
    endsWith?: string;
    not?: NestedStringFilter | string;
  };

  export type NestedBoolFilter = {
    equals?: boolean;
    not?: NestedBoolFilter | boolean;
  };

  export type NestedStringNullableFilter = {
    equals?: string | null;
    in?: Enumerable<string> | null;
    notIn?: Enumerable<string> | null;
    lt?: string;
    lte?: string;
    gt?: string;
    gte?: string;
    contains?: string;
    startsWith?: string;
    endsWith?: string;
    not?: NestedStringNullableFilter | string | null;
  };

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null;
    in?: Enumerable<Date> | Enumerable<string> | null;
    notIn?: Enumerable<Date> | Enumerable<string> | null;
    lt?: Date | string;
    lte?: Date | string;
    gt?: Date | string;
    gte?: Date | string;
    not?: NestedDateTimeNullableFilter | Date | string | null;
  };

  export type NestedStringWithAggregatesFilter = {
    equals?: string;
    in?: Enumerable<string>;
    notIn?: Enumerable<string>;
    lt?: string;
    lte?: string;
    gt?: string;
    gte?: string;
    contains?: string;
    startsWith?: string;
    endsWith?: string;
    not?: NestedStringWithAggregatesFilter | string;
    _count?: NestedIntFilter;
    _min?: NestedStringFilter;
    _max?: NestedStringFilter;
  };

  export type NestedIntFilter = {
    equals?: number;
    in?: Enumerable<number>;
    notIn?: Enumerable<number>;
    lt?: number;
    lte?: number;
    gt?: number;
    gte?: number;
    not?: NestedIntFilter | number;
  };

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean;
    not?: NestedBoolWithAggregatesFilter | boolean;
    _count?: NestedIntFilter;
    _min?: NestedBoolFilter;
    _max?: NestedBoolFilter;
  };

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null;
    in?: Enumerable<string> | null;
    notIn?: Enumerable<string> | null;
    lt?: string;
    lte?: string;
    gt?: string;
    gte?: string;
    contains?: string;
    startsWith?: string;
    endsWith?: string;
    not?: NestedStringNullableWithAggregatesFilter | string | null;
    _count?: NestedIntNullableFilter;
    _min?: NestedStringNullableFilter;
    _max?: NestedStringNullableFilter;
  };

  export type NestedIntNullableFilter = {
    equals?: number | null;
    in?: Enumerable<number> | null;
    notIn?: Enumerable<number> | null;
    lt?: number;
    lte?: number;
    gt?: number;
    gte?: number;
    not?: NestedIntNullableFilter | number | null;
  };

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null;
    in?: Enumerable<Date> | Enumerable<string> | null;
    notIn?: Enumerable<Date> | Enumerable<string> | null;
    lt?: Date | string;
    lte?: Date | string;
    gt?: Date | string;
    gte?: Date | string;
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null;
    _count?: NestedIntNullableFilter;
    _min?: NestedDateTimeNullableFilter;
    _max?: NestedDateTimeNullableFilter;
  };

  export type NestedEnumRestauRoleFilter = {
    equals?: RestauRole;
    in?: Enumerable<RestauRole>;
    notIn?: Enumerable<RestauRole>;
    not?: NestedEnumRestauRoleFilter | RestauRole;
  };

  export type NestedEnumRestauRoleWithAggregatesFilter = {
    equals?: RestauRole;
    in?: Enumerable<RestauRole>;
    notIn?: Enumerable<RestauRole>;
    not?: NestedEnumRestauRoleWithAggregatesFilter | RestauRole;
    _count?: NestedIntFilter;
    _min?: NestedEnumRestauRoleFilter;
    _max?: NestedEnumRestauRoleFilter;
  };

  export type RoleCreateWithoutUserInput = {
    roleId?: string;
    userRole: string;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
  };

  export type RoleUncheckedCreateWithoutUserInput = {
    roleId?: string;
    userRole: string;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
  };

  export type RoleCreateOrConnectWithoutUserInput = {
    where: RoleWhereUniqueInput;
    create: XOR<
      RoleCreateWithoutUserInput,
      RoleUncheckedCreateWithoutUserInput
    >;
  };

  export type TokensCreateWithoutUserInput = {
    tokenId?: string;
    token: string;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
  };

  export type TokensUncheckedCreateWithoutUserInput = {
    tokenId?: string;
    token: string;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
  };

  export type TokensCreateOrConnectWithoutUserInput = {
    where: TokensWhereUniqueInput;
    create: XOR<
      TokensCreateWithoutUserInput,
      TokensUncheckedCreateWithoutUserInput
    >;
  };

  export type TokensCreateManyUserInputEnvelope = {
    data: Enumerable<TokensCreateManyUserInput>;
    skipDuplicates?: boolean;
  };

  export type AddressCreateWithoutUserInput = {
    addressId?: string;
    commune?: string | null;
    address: string;
    longitude: string;
    latitude: string;
    restauId?: string | null;
    userId?: string | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    Restaurant?: RestaurantCreateNestedManyWithoutRestauAddressInput;
  };

  export type AddressUncheckedCreateWithoutUserInput = {
    addressId?: string;
    commune?: string | null;
    address: string;
    longitude: string;
    latitude: string;
    restauId?: string | null;
    userId?: string | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    Restaurant?: RestaurantUncheckedCreateNestedManyWithoutRestauAddressInput;
  };

  export type AddressCreateOrConnectWithoutUserInput = {
    where: AddressWhereUniqueInput;
    create: XOR<
      AddressCreateWithoutUserInput,
      AddressUncheckedCreateWithoutUserInput
    >;
  };

  export type RoleUpsertWithoutUserInput = {
    update: XOR<
      RoleUpdateWithoutUserInput,
      RoleUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      RoleCreateWithoutUserInput,
      RoleUncheckedCreateWithoutUserInput
    >;
  };

  export type RoleUpdateWithoutUserInput = {
    roleId?: StringFieldUpdateOperationsInput | string;
    userRole?: StringFieldUpdateOperationsInput | string;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type RoleUncheckedUpdateWithoutUserInput = {
    roleId?: StringFieldUpdateOperationsInput | string;
    userRole?: StringFieldUpdateOperationsInput | string;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type TokensUpsertWithWhereUniqueWithoutUserInput = {
    where: TokensWhereUniqueInput;
    update: XOR<
      TokensUpdateWithoutUserInput,
      TokensUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      TokensCreateWithoutUserInput,
      TokensUncheckedCreateWithoutUserInput
    >;
  };

  export type TokensUpdateWithWhereUniqueWithoutUserInput = {
    where: TokensWhereUniqueInput;
    data: XOR<
      TokensUpdateWithoutUserInput,
      TokensUncheckedUpdateWithoutUserInput
    >;
  };

  export type TokensUpdateManyWithWhereWithoutUserInput = {
    where: TokensScalarWhereInput;
    data: XOR<
      TokensUpdateManyMutationInput,
      TokensUncheckedUpdateManyWithoutTokenInput
    >;
  };

  export type TokensScalarWhereInput = {
    AND?: Enumerable<TokensScalarWhereInput>;
    OR?: Enumerable<TokensScalarWhereInput>;
    NOT?: Enumerable<TokensScalarWhereInput>;
    tokenId?: StringFilter | string;
    token?: StringFilter | string;
    userId?: StringFilter | string;
    createdAt?: DateTimeNullableFilter | Date | string | null;
    updatedAt?: DateTimeNullableFilter | Date | string | null;
  };

  export type AddressUpsertWithoutUserInput = {
    update: XOR<
      AddressUpdateWithoutUserInput,
      AddressUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      AddressCreateWithoutUserInput,
      AddressUncheckedCreateWithoutUserInput
    >;
  };

  export type AddressUpdateWithoutUserInput = {
    addressId?: StringFieldUpdateOperationsInput | string;
    commune?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: StringFieldUpdateOperationsInput | string;
    longitude?: StringFieldUpdateOperationsInput | string;
    latitude?: StringFieldUpdateOperationsInput | string;
    restauId?: NullableStringFieldUpdateOperationsInput | string | null;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    Restaurant?: RestaurantUpdateManyWithoutRestauAddressInput;
  };

  export type AddressUncheckedUpdateWithoutUserInput = {
    addressId?: StringFieldUpdateOperationsInput | string;
    commune?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: StringFieldUpdateOperationsInput | string;
    longitude?: StringFieldUpdateOperationsInput | string;
    latitude?: StringFieldUpdateOperationsInput | string;
    restauId?: NullableStringFieldUpdateOperationsInput | string | null;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    Restaurant?: RestaurantUncheckedUpdateManyWithoutRestauAddressInput;
  };

  export type UserCreateWithoutTokenInput = {
    userId?: string;
    phoneNumber: string;
    isPhoneConfirmed?: boolean;
    username: string;
    password: string;
    completeName?: string | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    Role: RoleCreateNestedOneWithoutUserInput;
    UserAddress?: AddressCreateNestedOneWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutTokenInput = {
    userId?: string;
    phoneNumber: string;
    isPhoneConfirmed?: boolean;
    username: string;
    password: string;
    completeName?: string | null;
    userRoleId: string;
    userAddressId?: string | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
  };

  export type UserCreateOrConnectWithoutTokenInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutTokenInput,
      UserUncheckedCreateWithoutTokenInput
    >;
  };

  export type UserUpsertWithoutTokenInput = {
    update: XOR<
      UserUpdateWithoutTokenInput,
      UserUncheckedUpdateWithoutTokenInput
    >;
    create: XOR<
      UserCreateWithoutTokenInput,
      UserUncheckedCreateWithoutTokenInput
    >;
  };

  export type UserUpdateWithoutTokenInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    isPhoneConfirmed?: BoolFieldUpdateOperationsInput | boolean;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    completeName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    Role?: RoleUpdateOneRequiredWithoutUserInput;
    UserAddress?: AddressUpdateOneWithoutUserInput;
  };

  export type UserUncheckedUpdateWithoutTokenInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    isPhoneConfirmed?: BoolFieldUpdateOperationsInput | boolean;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    completeName?: NullableStringFieldUpdateOperationsInput | string | null;
    userRoleId?: StringFieldUpdateOperationsInput | string;
    userAddressId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type UserCreateWithoutRoleInput = {
    userId?: string;
    phoneNumber: string;
    isPhoneConfirmed?: boolean;
    username: string;
    password: string;
    completeName?: string | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    Token?: TokensCreateNestedManyWithoutUserInput;
    UserAddress?: AddressCreateNestedOneWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutRoleInput = {
    userId?: string;
    phoneNumber: string;
    isPhoneConfirmed?: boolean;
    username: string;
    password: string;
    completeName?: string | null;
    userAddressId?: string | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    Token?: TokensUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutRoleInput,
      UserUncheckedCreateWithoutRoleInput
    >;
  };

  export type UserCreateManyRoleInputEnvelope = {
    data: Enumerable<UserCreateManyRoleInput>;
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput;
    update: XOR<
      UserUpdateWithoutRoleInput,
      UserUncheckedUpdateWithoutRoleInput
    >;
    create: XOR<
      UserCreateWithoutRoleInput,
      UserUncheckedCreateWithoutRoleInput
    >;
  };

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput;
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>;
  };

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput;
    data: XOR<
      UserUpdateManyMutationInput,
      UserUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>;
    OR?: Enumerable<UserScalarWhereInput>;
    NOT?: Enumerable<UserScalarWhereInput>;
    userId?: StringFilter | string;
    phoneNumber?: StringFilter | string;
    isPhoneConfirmed?: BoolFilter | boolean;
    username?: StringFilter | string;
    password?: StringFilter | string;
    completeName?: StringNullableFilter | string | null;
    userRoleId?: StringFilter | string;
    userAddressId?: StringNullableFilter | string | null;
    createdAt?: DateTimeNullableFilter | Date | string | null;
    updatedAt?: DateTimeNullableFilter | Date | string | null;
  };

  export type UserCreateWithoutUserAddressInput = {
    userId?: string;
    phoneNumber: string;
    isPhoneConfirmed?: boolean;
    username: string;
    password: string;
    completeName?: string | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    Role: RoleCreateNestedOneWithoutUserInput;
    Token?: TokensCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutUserAddressInput = {
    userId?: string;
    phoneNumber: string;
    isPhoneConfirmed?: boolean;
    username: string;
    password: string;
    completeName?: string | null;
    userRoleId: string;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    Token?: TokensUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutUserAddressInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutUserAddressInput,
      UserUncheckedCreateWithoutUserAddressInput
    >;
  };

  export type UserCreateManyUserAddressInputEnvelope = {
    data: Enumerable<UserCreateManyUserAddressInput>;
    skipDuplicates?: boolean;
  };

  export type RestaurantCreateWithoutRestauAddressInput = {
    restauId?: string;
    restauName: string;
    restauDescription: string;
    phoneNumber?: string | null;
    email?: string | null;
    isActive?: boolean;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    RestauImages?: RestauImagesCreateNestedOneWithoutRestaurantInput;
    RestaurantUser?: RestauUserCreateNestedManyWithoutRestaurantInput;
  };

  export type RestaurantUncheckedCreateWithoutRestauAddressInput = {
    restauId?: string;
    restauName: string;
    restauDescription: string;
    phoneNumber?: string | null;
    email?: string | null;
    mainImageId?: string | null;
    isActive?: boolean;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    RestaurantUser?: RestauUserUncheckedCreateNestedManyWithoutRestaurantInput;
  };

  export type RestaurantCreateOrConnectWithoutRestauAddressInput = {
    where: RestaurantWhereUniqueInput;
    create: XOR<
      RestaurantCreateWithoutRestauAddressInput,
      RestaurantUncheckedCreateWithoutRestauAddressInput
    >;
  };

  export type RestaurantCreateManyRestauAddressInputEnvelope = {
    data: Enumerable<RestaurantCreateManyRestauAddressInput>;
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithWhereUniqueWithoutUserAddressInput = {
    where: UserWhereUniqueInput;
    update: XOR<
      UserUpdateWithoutUserAddressInput,
      UserUncheckedUpdateWithoutUserAddressInput
    >;
    create: XOR<
      UserCreateWithoutUserAddressInput,
      UserUncheckedCreateWithoutUserAddressInput
    >;
  };

  export type UserUpdateWithWhereUniqueWithoutUserAddressInput = {
    where: UserWhereUniqueInput;
    data: XOR<
      UserUpdateWithoutUserAddressInput,
      UserUncheckedUpdateWithoutUserAddressInput
    >;
  };

  export type UserUpdateManyWithWhereWithoutUserAddressInput = {
    where: UserScalarWhereInput;
    data: XOR<
      UserUpdateManyMutationInput,
      UserUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type RestaurantUpsertWithWhereUniqueWithoutRestauAddressInput = {
    where: RestaurantWhereUniqueInput;
    update: XOR<
      RestaurantUpdateWithoutRestauAddressInput,
      RestaurantUncheckedUpdateWithoutRestauAddressInput
    >;
    create: XOR<
      RestaurantCreateWithoutRestauAddressInput,
      RestaurantUncheckedCreateWithoutRestauAddressInput
    >;
  };

  export type RestaurantUpdateWithWhereUniqueWithoutRestauAddressInput = {
    where: RestaurantWhereUniqueInput;
    data: XOR<
      RestaurantUpdateWithoutRestauAddressInput,
      RestaurantUncheckedUpdateWithoutRestauAddressInput
    >;
  };

  export type RestaurantUpdateManyWithWhereWithoutRestauAddressInput = {
    where: RestaurantScalarWhereInput;
    data: XOR<
      RestaurantUpdateManyMutationInput,
      RestaurantUncheckedUpdateManyWithoutRestaurantInput
    >;
  };

  export type RestaurantScalarWhereInput = {
    AND?: Enumerable<RestaurantScalarWhereInput>;
    OR?: Enumerable<RestaurantScalarWhereInput>;
    NOT?: Enumerable<RestaurantScalarWhereInput>;
    restauId?: StringFilter | string;
    restauName?: StringFilter | string;
    restauDescription?: StringFilter | string;
    phoneNumber?: StringNullableFilter | string | null;
    email?: StringNullableFilter | string | null;
    restauAddressId?: StringNullableFilter | string | null;
    mainImageId?: StringNullableFilter | string | null;
    isActive?: BoolFilter | boolean;
    createdAt?: DateTimeNullableFilter | Date | string | null;
    updatedAt?: DateTimeNullableFilter | Date | string | null;
  };

  export type AddressCreateWithoutRestaurantInput = {
    addressId?: string;
    commune?: string | null;
    address: string;
    longitude: string;
    latitude: string;
    restauId?: string | null;
    userId?: string | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    User?: UserCreateNestedManyWithoutUserAddressInput;
  };

  export type AddressUncheckedCreateWithoutRestaurantInput = {
    addressId?: string;
    commune?: string | null;
    address: string;
    longitude: string;
    latitude: string;
    restauId?: string | null;
    userId?: string | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    User?: UserUncheckedCreateNestedManyWithoutUserAddressInput;
  };

  export type AddressCreateOrConnectWithoutRestaurantInput = {
    where: AddressWhereUniqueInput;
    create: XOR<
      AddressCreateWithoutRestaurantInput,
      AddressUncheckedCreateWithoutRestaurantInput
    >;
  };

  export type RestauImagesCreateWithoutRestaurantInput = {
    imageId?: string;
    address: string;
    publicUrl: string;
    imageUrl: string;
    restauId?: string | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    RestauUser?: RestauUserCreateNestedManyWithoutRestauImagesInput;
  };

  export type RestauImagesUncheckedCreateWithoutRestaurantInput = {
    imageId?: string;
    address: string;
    publicUrl: string;
    imageUrl: string;
    restauId?: string | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    RestauUser?: RestauUserUncheckedCreateNestedManyWithoutRestauImagesInput;
  };

  export type RestauImagesCreateOrConnectWithoutRestaurantInput = {
    where: RestauImagesWhereUniqueInput;
    create: XOR<
      RestauImagesCreateWithoutRestaurantInput,
      RestauImagesUncheckedCreateWithoutRestaurantInput
    >;
  };

  export type RestauUserCreateWithoutRestaurantInput = {
    restauUserId?: string;
    userName: string;
    phoneNumber: string;
    completeName: string;
    password: string;
    role?: RestauRole;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    Token?: RestauTokensCreateNestedManyWithoutRestauUserInput;
    RestauImages?: RestauImagesCreateNestedOneWithoutRestauUserInput;
  };

  export type RestauUserUncheckedCreateWithoutRestaurantInput = {
    restauUserId?: string;
    userName: string;
    phoneNumber: string;
    completeName: string;
    userImage: string;
    password: string;
    role?: RestauRole;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    Token?: RestauTokensUncheckedCreateNestedManyWithoutRestauUserInput;
  };

  export type RestauUserCreateOrConnectWithoutRestaurantInput = {
    where: RestauUserWhereUniqueInput;
    create: XOR<
      RestauUserCreateWithoutRestaurantInput,
      RestauUserUncheckedCreateWithoutRestaurantInput
    >;
  };

  export type RestauUserCreateManyRestaurantInputEnvelope = {
    data: Enumerable<RestauUserCreateManyRestaurantInput>;
    skipDuplicates?: boolean;
  };

  export type AddressUpsertWithoutRestaurantInput = {
    update: XOR<
      AddressUpdateWithoutRestaurantInput,
      AddressUncheckedUpdateWithoutRestaurantInput
    >;
    create: XOR<
      AddressCreateWithoutRestaurantInput,
      AddressUncheckedCreateWithoutRestaurantInput
    >;
  };

  export type AddressUpdateWithoutRestaurantInput = {
    addressId?: StringFieldUpdateOperationsInput | string;
    commune?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: StringFieldUpdateOperationsInput | string;
    longitude?: StringFieldUpdateOperationsInput | string;
    latitude?: StringFieldUpdateOperationsInput | string;
    restauId?: NullableStringFieldUpdateOperationsInput | string | null;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    User?: UserUpdateManyWithoutUserAddressInput;
  };

  export type AddressUncheckedUpdateWithoutRestaurantInput = {
    addressId?: StringFieldUpdateOperationsInput | string;
    commune?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: StringFieldUpdateOperationsInput | string;
    longitude?: StringFieldUpdateOperationsInput | string;
    latitude?: StringFieldUpdateOperationsInput | string;
    restauId?: NullableStringFieldUpdateOperationsInput | string | null;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    User?: UserUncheckedUpdateManyWithoutUserAddressInput;
  };

  export type RestauImagesUpsertWithoutRestaurantInput = {
    update: XOR<
      RestauImagesUpdateWithoutRestaurantInput,
      RestauImagesUncheckedUpdateWithoutRestaurantInput
    >;
    create: XOR<
      RestauImagesCreateWithoutRestaurantInput,
      RestauImagesUncheckedCreateWithoutRestaurantInput
    >;
  };

  export type RestauImagesUpdateWithoutRestaurantInput = {
    imageId?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    publicUrl?: StringFieldUpdateOperationsInput | string;
    imageUrl?: StringFieldUpdateOperationsInput | string;
    restauId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    RestauUser?: RestauUserUpdateManyWithoutRestauImagesInput;
  };

  export type RestauImagesUncheckedUpdateWithoutRestaurantInput = {
    imageId?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    publicUrl?: StringFieldUpdateOperationsInput | string;
    imageUrl?: StringFieldUpdateOperationsInput | string;
    restauId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    RestauUser?: RestauUserUncheckedUpdateManyWithoutRestauImagesInput;
  };

  export type RestauUserUpsertWithWhereUniqueWithoutRestaurantInput = {
    where: RestauUserWhereUniqueInput;
    update: XOR<
      RestauUserUpdateWithoutRestaurantInput,
      RestauUserUncheckedUpdateWithoutRestaurantInput
    >;
    create: XOR<
      RestauUserCreateWithoutRestaurantInput,
      RestauUserUncheckedCreateWithoutRestaurantInput
    >;
  };

  export type RestauUserUpdateWithWhereUniqueWithoutRestaurantInput = {
    where: RestauUserWhereUniqueInput;
    data: XOR<
      RestauUserUpdateWithoutRestaurantInput,
      RestauUserUncheckedUpdateWithoutRestaurantInput
    >;
  };

  export type RestauUserUpdateManyWithWhereWithoutRestaurantInput = {
    where: RestauUserScalarWhereInput;
    data: XOR<
      RestauUserUpdateManyMutationInput,
      RestauUserUncheckedUpdateManyWithoutRestaurantUserInput
    >;
  };

  export type RestauUserScalarWhereInput = {
    AND?: Enumerable<RestauUserScalarWhereInput>;
    OR?: Enumerable<RestauUserScalarWhereInput>;
    NOT?: Enumerable<RestauUserScalarWhereInput>;
    restauUserId?: StringFilter | string;
    restauId?: StringFilter | string;
    userName?: StringFilter | string;
    phoneNumber?: StringFilter | string;
    completeName?: StringFilter | string;
    userImage?: StringFilter | string;
    password?: StringFilter | string;
    role?: EnumRestauRoleFilter | RestauRole;
    createdAt?: DateTimeNullableFilter | Date | string | null;
    updatedAt?: DateTimeNullableFilter | Date | string | null;
  };

  export type RestauUserCreateWithoutTokenInput = {
    restauUserId?: string;
    userName: string;
    phoneNumber: string;
    completeName: string;
    password: string;
    role?: RestauRole;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    RestauImages?: RestauImagesCreateNestedOneWithoutRestauUserInput;
    Restaurant?: RestaurantCreateNestedOneWithoutRestaurantUserInput;
  };

  export type RestauUserUncheckedCreateWithoutTokenInput = {
    restauUserId?: string;
    restauId: string;
    userName: string;
    phoneNumber: string;
    completeName: string;
    userImage: string;
    password: string;
    role?: RestauRole;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
  };

  export type RestauUserCreateOrConnectWithoutTokenInput = {
    where: RestauUserWhereUniqueInput;
    create: XOR<
      RestauUserCreateWithoutTokenInput,
      RestauUserUncheckedCreateWithoutTokenInput
    >;
  };

  export type RestauUserUpsertWithoutTokenInput = {
    update: XOR<
      RestauUserUpdateWithoutTokenInput,
      RestauUserUncheckedUpdateWithoutTokenInput
    >;
    create: XOR<
      RestauUserCreateWithoutTokenInput,
      RestauUserUncheckedCreateWithoutTokenInput
    >;
  };

  export type RestauUserUpdateWithoutTokenInput = {
    restauUserId?: StringFieldUpdateOperationsInput | string;
    userName?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    completeName?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    role?: EnumRestauRoleFieldUpdateOperationsInput | RestauRole;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    RestauImages?: RestauImagesUpdateOneWithoutRestauUserInput;
    Restaurant?: RestaurantUpdateOneWithoutRestaurantUserInput;
  };

  export type RestauUserUncheckedUpdateWithoutTokenInput = {
    restauUserId?: StringFieldUpdateOperationsInput | string;
    restauId?: StringFieldUpdateOperationsInput | string;
    userName?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    completeName?: StringFieldUpdateOperationsInput | string;
    userImage?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    role?: EnumRestauRoleFieldUpdateOperationsInput | RestauRole;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type RestauTokensCreateWithoutRestauUserInput = {
    tokenId?: string;
    token: string;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
  };

  export type RestauTokensUncheckedCreateWithoutRestauUserInput = {
    tokenId?: string;
    token: string;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
  };

  export type RestauTokensCreateOrConnectWithoutRestauUserInput = {
    where: RestauTokensWhereUniqueInput;
    create: XOR<
      RestauTokensCreateWithoutRestauUserInput,
      RestauTokensUncheckedCreateWithoutRestauUserInput
    >;
  };

  export type RestauTokensCreateManyRestauUserInputEnvelope = {
    data: Enumerable<RestauTokensCreateManyRestauUserInput>;
    skipDuplicates?: boolean;
  };

  export type RestauImagesCreateWithoutRestauUserInput = {
    imageId?: string;
    address: string;
    publicUrl: string;
    imageUrl: string;
    restauId?: string | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    Restaurant?: RestaurantCreateNestedManyWithoutRestauImagesInput;
  };

  export type RestauImagesUncheckedCreateWithoutRestauUserInput = {
    imageId?: string;
    address: string;
    publicUrl: string;
    imageUrl: string;
    restauId?: string | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    Restaurant?: RestaurantUncheckedCreateNestedManyWithoutRestauImagesInput;
  };

  export type RestauImagesCreateOrConnectWithoutRestauUserInput = {
    where: RestauImagesWhereUniqueInput;
    create: XOR<
      RestauImagesCreateWithoutRestauUserInput,
      RestauImagesUncheckedCreateWithoutRestauUserInput
    >;
  };

  export type RestaurantCreateWithoutRestaurantUserInput = {
    restauId?: string;
    restauName: string;
    restauDescription: string;
    phoneNumber?: string | null;
    email?: string | null;
    isActive?: boolean;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    RestauAddress?: AddressCreateNestedOneWithoutRestaurantInput;
    RestauImages?: RestauImagesCreateNestedOneWithoutRestaurantInput;
  };

  export type RestaurantUncheckedCreateWithoutRestaurantUserInput = {
    restauId?: string;
    restauName: string;
    restauDescription: string;
    phoneNumber?: string | null;
    email?: string | null;
    restauAddressId?: string | null;
    mainImageId?: string | null;
    isActive?: boolean;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
  };

  export type RestaurantCreateOrConnectWithoutRestaurantUserInput = {
    where: RestaurantWhereUniqueInput;
    create: XOR<
      RestaurantCreateWithoutRestaurantUserInput,
      RestaurantUncheckedCreateWithoutRestaurantUserInput
    >;
  };

  export type RestauTokensUpsertWithWhereUniqueWithoutRestauUserInput = {
    where: RestauTokensWhereUniqueInput;
    update: XOR<
      RestauTokensUpdateWithoutRestauUserInput,
      RestauTokensUncheckedUpdateWithoutRestauUserInput
    >;
    create: XOR<
      RestauTokensCreateWithoutRestauUserInput,
      RestauTokensUncheckedCreateWithoutRestauUserInput
    >;
  };

  export type RestauTokensUpdateWithWhereUniqueWithoutRestauUserInput = {
    where: RestauTokensWhereUniqueInput;
    data: XOR<
      RestauTokensUpdateWithoutRestauUserInput,
      RestauTokensUncheckedUpdateWithoutRestauUserInput
    >;
  };

  export type RestauTokensUpdateManyWithWhereWithoutRestauUserInput = {
    where: RestauTokensScalarWhereInput;
    data: XOR<
      RestauTokensUpdateManyMutationInput,
      RestauTokensUncheckedUpdateManyWithoutTokenInput
    >;
  };

  export type RestauTokensScalarWhereInput = {
    AND?: Enumerable<RestauTokensScalarWhereInput>;
    OR?: Enumerable<RestauTokensScalarWhereInput>;
    NOT?: Enumerable<RestauTokensScalarWhereInput>;
    tokenId?: StringFilter | string;
    token?: StringFilter | string;
    restauUserId?: StringFilter | string;
    createdAt?: DateTimeNullableFilter | Date | string | null;
    updatedAt?: DateTimeNullableFilter | Date | string | null;
  };

  export type RestauImagesUpsertWithoutRestauUserInput = {
    update: XOR<
      RestauImagesUpdateWithoutRestauUserInput,
      RestauImagesUncheckedUpdateWithoutRestauUserInput
    >;
    create: XOR<
      RestauImagesCreateWithoutRestauUserInput,
      RestauImagesUncheckedCreateWithoutRestauUserInput
    >;
  };

  export type RestauImagesUpdateWithoutRestauUserInput = {
    imageId?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    publicUrl?: StringFieldUpdateOperationsInput | string;
    imageUrl?: StringFieldUpdateOperationsInput | string;
    restauId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    Restaurant?: RestaurantUpdateManyWithoutRestauImagesInput;
  };

  export type RestauImagesUncheckedUpdateWithoutRestauUserInput = {
    imageId?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    publicUrl?: StringFieldUpdateOperationsInput | string;
    imageUrl?: StringFieldUpdateOperationsInput | string;
    restauId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    Restaurant?: RestaurantUncheckedUpdateManyWithoutRestauImagesInput;
  };

  export type RestaurantUpsertWithoutRestaurantUserInput = {
    update: XOR<
      RestaurantUpdateWithoutRestaurantUserInput,
      RestaurantUncheckedUpdateWithoutRestaurantUserInput
    >;
    create: XOR<
      RestaurantCreateWithoutRestaurantUserInput,
      RestaurantUncheckedCreateWithoutRestaurantUserInput
    >;
  };

  export type RestaurantUpdateWithoutRestaurantUserInput = {
    restauId?: StringFieldUpdateOperationsInput | string;
    restauName?: StringFieldUpdateOperationsInput | string;
    restauDescription?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    RestauAddress?: AddressUpdateOneWithoutRestaurantInput;
    RestauImages?: RestauImagesUpdateOneWithoutRestaurantInput;
  };

  export type RestaurantUncheckedUpdateWithoutRestaurantUserInput = {
    restauId?: StringFieldUpdateOperationsInput | string;
    restauName?: StringFieldUpdateOperationsInput | string;
    restauDescription?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    restauAddressId?: NullableStringFieldUpdateOperationsInput | string | null;
    mainImageId?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type RestaurantCreateWithoutRestauImagesInput = {
    restauId?: string;
    restauName: string;
    restauDescription: string;
    phoneNumber?: string | null;
    email?: string | null;
    isActive?: boolean;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    RestauAddress?: AddressCreateNestedOneWithoutRestaurantInput;
    RestaurantUser?: RestauUserCreateNestedManyWithoutRestaurantInput;
  };

  export type RestaurantUncheckedCreateWithoutRestauImagesInput = {
    restauId?: string;
    restauName: string;
    restauDescription: string;
    phoneNumber?: string | null;
    email?: string | null;
    restauAddressId?: string | null;
    isActive?: boolean;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    RestaurantUser?: RestauUserUncheckedCreateNestedManyWithoutRestaurantInput;
  };

  export type RestaurantCreateOrConnectWithoutRestauImagesInput = {
    where: RestaurantWhereUniqueInput;
    create: XOR<
      RestaurantCreateWithoutRestauImagesInput,
      RestaurantUncheckedCreateWithoutRestauImagesInput
    >;
  };

  export type RestaurantCreateManyRestauImagesInputEnvelope = {
    data: Enumerable<RestaurantCreateManyRestauImagesInput>;
    skipDuplicates?: boolean;
  };

  export type RestauUserCreateWithoutRestauImagesInput = {
    restauUserId?: string;
    userName: string;
    phoneNumber: string;
    completeName: string;
    password: string;
    role?: RestauRole;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    Token?: RestauTokensCreateNestedManyWithoutRestauUserInput;
    Restaurant?: RestaurantCreateNestedOneWithoutRestaurantUserInput;
  };

  export type RestauUserUncheckedCreateWithoutRestauImagesInput = {
    restauUserId?: string;
    restauId: string;
    userName: string;
    phoneNumber: string;
    completeName: string;
    password: string;
    role?: RestauRole;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    Token?: RestauTokensUncheckedCreateNestedManyWithoutRestauUserInput;
  };

  export type RestauUserCreateOrConnectWithoutRestauImagesInput = {
    where: RestauUserWhereUniqueInput;
    create: XOR<
      RestauUserCreateWithoutRestauImagesInput,
      RestauUserUncheckedCreateWithoutRestauImagesInput
    >;
  };

  export type RestauUserCreateManyRestauImagesInputEnvelope = {
    data: Enumerable<RestauUserCreateManyRestauImagesInput>;
    skipDuplicates?: boolean;
  };

  export type RestaurantUpsertWithWhereUniqueWithoutRestauImagesInput = {
    where: RestaurantWhereUniqueInput;
    update: XOR<
      RestaurantUpdateWithoutRestauImagesInput,
      RestaurantUncheckedUpdateWithoutRestauImagesInput
    >;
    create: XOR<
      RestaurantCreateWithoutRestauImagesInput,
      RestaurantUncheckedCreateWithoutRestauImagesInput
    >;
  };

  export type RestaurantUpdateWithWhereUniqueWithoutRestauImagesInput = {
    where: RestaurantWhereUniqueInput;
    data: XOR<
      RestaurantUpdateWithoutRestauImagesInput,
      RestaurantUncheckedUpdateWithoutRestauImagesInput
    >;
  };

  export type RestaurantUpdateManyWithWhereWithoutRestauImagesInput = {
    where: RestaurantScalarWhereInput;
    data: XOR<
      RestaurantUpdateManyMutationInput,
      RestaurantUncheckedUpdateManyWithoutRestaurantInput
    >;
  };

  export type RestauUserUpsertWithWhereUniqueWithoutRestauImagesInput = {
    where: RestauUserWhereUniqueInput;
    update: XOR<
      RestauUserUpdateWithoutRestauImagesInput,
      RestauUserUncheckedUpdateWithoutRestauImagesInput
    >;
    create: XOR<
      RestauUserCreateWithoutRestauImagesInput,
      RestauUserUncheckedCreateWithoutRestauImagesInput
    >;
  };

  export type RestauUserUpdateWithWhereUniqueWithoutRestauImagesInput = {
    where: RestauUserWhereUniqueInput;
    data: XOR<
      RestauUserUpdateWithoutRestauImagesInput,
      RestauUserUncheckedUpdateWithoutRestauImagesInput
    >;
  };

  export type RestauUserUpdateManyWithWhereWithoutRestauImagesInput = {
    where: RestauUserScalarWhereInput;
    data: XOR<
      RestauUserUpdateManyMutationInput,
      RestauUserUncheckedUpdateManyWithoutRestauUserInput
    >;
  };

  export type TokensCreateManyUserInput = {
    tokenId?: string;
    token: string;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
  };

  export type TokensUpdateWithoutUserInput = {
    tokenId?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type TokensUncheckedUpdateWithoutUserInput = {
    tokenId?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type TokensUncheckedUpdateManyWithoutTokenInput = {
    tokenId?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type UserCreateManyRoleInput = {
    userId?: string;
    phoneNumber: string;
    isPhoneConfirmed?: boolean;
    username: string;
    password: string;
    completeName?: string | null;
    userAddressId?: string | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
  };

  export type UserUpdateWithoutRoleInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    isPhoneConfirmed?: BoolFieldUpdateOperationsInput | boolean;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    completeName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    Token?: TokensUpdateManyWithoutUserInput;
    UserAddress?: AddressUpdateOneWithoutUserInput;
  };

  export type UserUncheckedUpdateWithoutRoleInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    isPhoneConfirmed?: BoolFieldUpdateOperationsInput | boolean;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    completeName?: NullableStringFieldUpdateOperationsInput | string | null;
    userAddressId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    Token?: TokensUncheckedUpdateManyWithoutUserInput;
  };

  export type UserUncheckedUpdateManyWithoutUserInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    isPhoneConfirmed?: BoolFieldUpdateOperationsInput | boolean;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    completeName?: NullableStringFieldUpdateOperationsInput | string | null;
    userAddressId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type UserCreateManyUserAddressInput = {
    userId?: string;
    phoneNumber: string;
    isPhoneConfirmed?: boolean;
    username: string;
    password: string;
    completeName?: string | null;
    userRoleId: string;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
  };

  export type RestaurantCreateManyRestauAddressInput = {
    restauId?: string;
    restauName: string;
    restauDescription: string;
    phoneNumber?: string | null;
    email?: string | null;
    mainImageId?: string | null;
    isActive?: boolean;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
  };

  export type UserUpdateWithoutUserAddressInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    isPhoneConfirmed?: BoolFieldUpdateOperationsInput | boolean;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    completeName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    Role?: RoleUpdateOneRequiredWithoutUserInput;
    Token?: TokensUpdateManyWithoutUserInput;
  };

  export type UserUncheckedUpdateWithoutUserAddressInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    isPhoneConfirmed?: BoolFieldUpdateOperationsInput | boolean;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    completeName?: NullableStringFieldUpdateOperationsInput | string | null;
    userRoleId?: StringFieldUpdateOperationsInput | string;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    Token?: TokensUncheckedUpdateManyWithoutUserInput;
  };

  export type RestaurantUpdateWithoutRestauAddressInput = {
    restauId?: StringFieldUpdateOperationsInput | string;
    restauName?: StringFieldUpdateOperationsInput | string;
    restauDescription?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    RestauImages?: RestauImagesUpdateOneWithoutRestaurantInput;
    RestaurantUser?: RestauUserUpdateManyWithoutRestaurantInput;
  };

  export type RestaurantUncheckedUpdateWithoutRestauAddressInput = {
    restauId?: StringFieldUpdateOperationsInput | string;
    restauName?: StringFieldUpdateOperationsInput | string;
    restauDescription?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    mainImageId?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    RestaurantUser?: RestauUserUncheckedUpdateManyWithoutRestaurantInput;
  };

  export type RestaurantUncheckedUpdateManyWithoutRestaurantInput = {
    restauId?: StringFieldUpdateOperationsInput | string;
    restauName?: StringFieldUpdateOperationsInput | string;
    restauDescription?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    mainImageId?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type RestauUserCreateManyRestaurantInput = {
    restauUserId?: string;
    userName: string;
    phoneNumber: string;
    completeName: string;
    userImage: string;
    password: string;
    role?: RestauRole;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
  };

  export type RestauUserUpdateWithoutRestaurantInput = {
    restauUserId?: StringFieldUpdateOperationsInput | string;
    userName?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    completeName?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    role?: EnumRestauRoleFieldUpdateOperationsInput | RestauRole;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    Token?: RestauTokensUpdateManyWithoutRestauUserInput;
    RestauImages?: RestauImagesUpdateOneWithoutRestauUserInput;
  };

  export type RestauUserUncheckedUpdateWithoutRestaurantInput = {
    restauUserId?: StringFieldUpdateOperationsInput | string;
    userName?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    completeName?: StringFieldUpdateOperationsInput | string;
    userImage?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    role?: EnumRestauRoleFieldUpdateOperationsInput | RestauRole;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    Token?: RestauTokensUncheckedUpdateManyWithoutRestauUserInput;
  };

  export type RestauUserUncheckedUpdateManyWithoutRestaurantUserInput = {
    restauUserId?: StringFieldUpdateOperationsInput | string;
    userName?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    completeName?: StringFieldUpdateOperationsInput | string;
    userImage?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    role?: EnumRestauRoleFieldUpdateOperationsInput | RestauRole;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type RestauTokensCreateManyRestauUserInput = {
    tokenId?: string;
    token: string;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
  };

  export type RestauTokensUpdateWithoutRestauUserInput = {
    tokenId?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type RestauTokensUncheckedUpdateWithoutRestauUserInput = {
    tokenId?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type RestauTokensUncheckedUpdateManyWithoutTokenInput = {
    tokenId?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type RestaurantCreateManyRestauImagesInput = {
    restauId?: string;
    restauName: string;
    restauDescription: string;
    phoneNumber?: string | null;
    email?: string | null;
    restauAddressId?: string | null;
    isActive?: boolean;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
  };

  export type RestauUserCreateManyRestauImagesInput = {
    restauUserId?: string;
    restauId: string;
    userName: string;
    phoneNumber: string;
    completeName: string;
    password: string;
    role?: RestauRole;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
  };

  export type RestaurantUpdateWithoutRestauImagesInput = {
    restauId?: StringFieldUpdateOperationsInput | string;
    restauName?: StringFieldUpdateOperationsInput | string;
    restauDescription?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    RestauAddress?: AddressUpdateOneWithoutRestaurantInput;
    RestaurantUser?: RestauUserUpdateManyWithoutRestaurantInput;
  };

  export type RestaurantUncheckedUpdateWithoutRestauImagesInput = {
    restauId?: StringFieldUpdateOperationsInput | string;
    restauName?: StringFieldUpdateOperationsInput | string;
    restauDescription?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    restauAddressId?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    RestaurantUser?: RestauUserUncheckedUpdateManyWithoutRestaurantInput;
  };

  export type RestauUserUpdateWithoutRestauImagesInput = {
    restauUserId?: StringFieldUpdateOperationsInput | string;
    userName?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    completeName?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    role?: EnumRestauRoleFieldUpdateOperationsInput | RestauRole;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    Token?: RestauTokensUpdateManyWithoutRestauUserInput;
    Restaurant?: RestaurantUpdateOneWithoutRestaurantUserInput;
  };

  export type RestauUserUncheckedUpdateWithoutRestauImagesInput = {
    restauUserId?: StringFieldUpdateOperationsInput | string;
    restauId?: StringFieldUpdateOperationsInput | string;
    userName?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    completeName?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    role?: EnumRestauRoleFieldUpdateOperationsInput | RestauRole;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    Token?: RestauTokensUncheckedUpdateManyWithoutRestauUserInput;
  };

  export type RestauUserUncheckedUpdateManyWithoutRestauUserInput = {
    restauUserId?: StringFieldUpdateOperationsInput | string;
    restauId?: StringFieldUpdateOperationsInput | string;
    userName?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    completeName?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    role?: EnumRestauRoleFieldUpdateOperationsInput | RestauRole;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}
